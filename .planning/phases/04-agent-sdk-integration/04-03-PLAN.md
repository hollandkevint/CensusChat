---
phase: 04-agent-sdk-integration
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/src/agent/sessionManager.ts
  - backend/src/mcp/documentTools.ts
  - backend/src/mcp/mcpServer.ts
  - backend/src/agent/agentService.ts
autonomous: true

must_haves:
  truths:
    - "Conversational context persists across queries ('Now filter to income > $75K' references prior query)"
    - "Agent can generate Excel reports via MCP tool"
    - "Agent can generate PDF reports via MCP tool"
  artifacts:
    - path: "backend/src/agent/sessionManager.ts"
      provides: "Session tracking for conversational context"
      exports: ["AgentSessionManager", "getSessionManager"]
    - path: "backend/src/mcp/documentTools.ts"
      provides: "Excel and PDF generation MCP tools"
      exports: ["registerDocumentTools"]
  key_links:
    - from: "backend/src/mcp/documentTools.ts"
      to: "backend/src/services/excelExportService.ts"
      via: "import ExcelExportService"
      pattern: "ExcelExportService"
    - from: "backend/src/mcp/mcpServer.ts"
      to: "backend/src/mcp/documentTools.ts"
      via: "registerDocumentTools(server)"
      pattern: "registerDocumentTools"
    - from: "backend/src/agent/agentService.ts"
      to: "backend/src/agent/sessionManager.ts"
      via: "import getSessionManager"
      pattern: "getSessionManager"
---

<objective>
Add conversational session memory and document generation MCP tools for Excel/PDF reports.

Purpose: Enable follow-up queries that reference prior context and allow agent to generate structured documents.
Output: Session manager for context persistence, MCP tools wrapping existing Excel/PDF services.
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-agent-sdk-integration/04-RESEARCH.md
@.planning/phases/04-agent-sdk-integration/04-01-SUMMARY.md
@backend/src/agent/agentService.ts
@backend/src/services/excelExportService.ts
@backend/src/mcp/mcpServer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session manager for conversational context</name>
  <files>
    backend/src/agent/sessionManager.ts
  </files>
  <action>
Create `backend/src/agent/sessionManager.ts` for tracking conversation sessions:

```typescript
/**
 * Agent Session Manager
 * Tracks session IDs from Agent SDK for conversational context persistence
 * Enables follow-up queries like "Now filter to income > $75K" that reference prior context
 */

export interface SessionContext {
  sessionId: string;
  userId?: string;
  createdAt: Date;
  lastAccessedAt: Date;
  queryCount: number;
  lastQuery?: string;
  lastResult?: unknown;
}

/**
 * In-memory session manager
 * For production, consider Redis persistence
 */
export class AgentSessionManager {
  private sessions: Map<string, SessionContext> = new Map();
  private userToSession: Map<string, string> = new Map();
  private maxSessions: number;
  private sessionTTLMs: number;

  constructor(options?: { maxSessions?: number; sessionTTLMs?: number }) {
    this.maxSessions = options?.maxSessions || 1000;
    this.sessionTTLMs = options?.sessionTTLMs || 30 * 60 * 1000; // 30 minutes default
  }

  /**
   * Get or create session for a user
   * Returns existing session ID if user has active session
   */
  getOrCreateSession(userId: string): string {
    // Check for existing session
    const existingSessionId = this.userToSession.get(userId);
    if (existingSessionId) {
      const session = this.sessions.get(existingSessionId);
      if (session && !this.isExpired(session)) {
        session.lastAccessedAt = new Date();
        return existingSessionId;
      }
      // Expired, clean up
      this.deleteSession(existingSessionId);
    }

    // No session yet - return undefined, will be set after first Agent SDK call
    return "";
  }

  /**
   * Store session ID from Agent SDK response
   */
  storeSession(userId: string, sessionId: string, query?: string, result?: unknown): void {
    // Clean up old sessions if at capacity
    if (this.sessions.size >= this.maxSessions) {
      this.cleanupOldestSessions();
    }

    const now = new Date();
    const existing = this.sessions.get(sessionId);

    if (existing) {
      existing.lastAccessedAt = now;
      existing.queryCount++;
      existing.lastQuery = query;
      existing.lastResult = result;
    } else {
      this.sessions.set(sessionId, {
        sessionId,
        userId,
        createdAt: now,
        lastAccessedAt: now,
        queryCount: 1,
        lastQuery: query,
        lastResult: result,
      });
      this.userToSession.set(userId, sessionId);
    }
  }

  /**
   * Get session context
   */
  getSession(sessionId: string): SessionContext | undefined {
    const session = this.sessions.get(sessionId);
    if (session && !this.isExpired(session)) {
      return session;
    }
    return undefined;
  }

  /**
   * Get session ID for user
   */
  getSessionIdForUser(userId: string): string | undefined {
    const sessionId = this.userToSession.get(userId);
    if (sessionId) {
      const session = this.sessions.get(sessionId);
      if (session && !this.isExpired(session)) {
        return sessionId;
      }
    }
    return undefined;
  }

  /**
   * Delete a session
   */
  deleteSession(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session?.userId) {
      this.userToSession.delete(session.userId);
    }
    this.sessions.delete(sessionId);
  }

  /**
   * Clear all sessions for a user (logout)
   */
  clearUserSessions(userId: string): void {
    const sessionId = this.userToSession.get(userId);
    if (sessionId) {
      this.deleteSession(sessionId);
    }
  }

  /**
   * Get session stats
   */
  getStats(): { activeSessions: number; totalQueries: number } {
    let totalQueries = 0;
    for (const session of this.sessions.values()) {
      if (!this.isExpired(session)) {
        totalQueries += session.queryCount;
      }
    }
    return {
      activeSessions: this.sessions.size,
      totalQueries,
    };
  }

  private isExpired(session: SessionContext): boolean {
    return Date.now() - session.lastAccessedAt.getTime() > this.sessionTTLMs;
  }

  private cleanupOldestSessions(): void {
    const sorted = [...this.sessions.entries()].sort(
      (a, b) => a[1].lastAccessedAt.getTime() - b[1].lastAccessedAt.getTime()
    );
    // Remove oldest 10%
    const toRemove = Math.ceil(sorted.length * 0.1);
    for (let i = 0; i < toRemove; i++) {
      this.deleteSession(sorted[i][0]);
    }
  }
}

// Singleton instance
let sessionManagerInstance: AgentSessionManager | null = null;

export function getSessionManager(): AgentSessionManager {
  if (!sessionManagerInstance) {
    sessionManagerInstance = new AgentSessionManager();
  }
  return sessionManagerInstance;
}
```
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/agent/sessionManager.ts` compiles
  </verify>
  <done>
    - AgentSessionManager tracks user-to-session mapping
    - Sessions auto-expire after 30 minutes
    - getSessionManager() returns singleton
  </done>
</task>

<task type="auto">
  <name>Task 2: Create document generation MCP tools</name>
  <files>
    backend/src/mcp/documentTools.ts
  </files>
  <action>
Create `backend/src/mcp/documentTools.ts` wrapping existing Excel service:

```typescript
/**
 * Document Generation MCP Tools
 * Wraps existing ExcelExportService to expose as MCP tools
 * Agent SDK uses these tools for "generate Excel report" / "create PDF" requests
 */
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { ExcelExportService, ExportResult } from "../services/excelExportService";
import { z } from "zod";

// Schema for document generation input
const DocumentDataSchema = z.object({
  data: z.array(z.record(z.string(), z.unknown())),
  filename: z.string().optional(),
  title: z.string().optional(),
  includeMetadata: z.boolean().optional(),
  columns: z.array(z.string()).optional(),
});

type DocumentData = z.infer<typeof DocumentDataSchema>;

/**
 * Register document generation tools on MCP server
 */
export function registerDocumentTools(server: Server): void {
  // Excel generation tool
  server.tool(
    "generate_excel_report",
    "Generate an Excel spreadsheet from query results. Returns base64-encoded file content.",
    {
      data: {
        type: "array",
        items: { type: "object", additionalProperties: true },
        description: "Array of data records to include in the spreadsheet",
      },
      filename: {
        type: "string",
        description: "Optional filename (without extension)",
      },
      title: {
        type: "string",
        description: "Optional title for the report",
      },
      includeMetadata: {
        type: "boolean",
        description: "Whether to include metadata row (default: true)",
      },
      columns: {
        type: "array",
        items: { type: "string" },
        description: "Optional list of columns to include (default: all)",
      },
    },
    async (args) => {
      try {
        const input = DocumentDataSchema.parse(args);
        const result = await generateExcel(input);

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: true,
                filename: result.filename,
                mimeType: result.mimeType,
                size: result.size,
                // Base64 encode the buffer for transport
                content: result.buffer.toString("base64"),
              }),
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: false,
                error: error instanceof Error ? error.message : "Excel generation failed",
              }),
            },
          ],
          isError: true,
        };
      }
    }
  );

  // CSV generation tool (simpler alternative)
  server.tool(
    "generate_csv_report",
    "Generate a CSV file from query results. Returns the CSV content as text.",
    {
      data: {
        type: "array",
        items: { type: "object", additionalProperties: true },
        description: "Array of data records to include",
      },
      filename: {
        type: "string",
        description: "Optional filename (without extension)",
      },
      columns: {
        type: "array",
        items: { type: "string" },
        description: "Optional list of columns to include (default: all)",
      },
    },
    async (args) => {
      try {
        const input = DocumentDataSchema.parse(args);
        const csv = generateCsv(input);

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: true,
                filename: (input.filename || "export") + ".csv",
                mimeType: "text/csv",
                content: csv,
              }),
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: false,
                error: error instanceof Error ? error.message : "CSV generation failed",
              }),
            },
          ],
          isError: true,
        };
      }
    }
  );

  // PDF generation tool
  server.tool(
    "generate_pdf_report",
    "Generate a PDF report from query results. Returns base64-encoded file content.",
    {
      data: {
        type: "array",
        items: { type: "object", additionalProperties: true },
        description: "Array of data records to include",
      },
      title: {
        type: "string",
        description: "Report title",
      },
      filename: {
        type: "string",
        description: "Optional filename (without extension)",
      },
      columns: {
        type: "array",
        items: { type: "string" },
        description: "Optional list of columns to include (default: all)",
      },
    },
    async (args) => {
      try {
        const input = DocumentDataSchema.parse(args);
        const result = await generatePdf(input);

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: true,
                filename: result.filename,
                mimeType: result.mimeType,
                size: result.size,
                content: result.buffer.toString("base64"),
              }),
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: false,
                error: error instanceof Error ? error.message : "PDF generation failed",
              }),
            },
          ],
          isError: true,
        };
      }
    }
  );

  console.log("[MCP] Registered document generation tools: generate_excel_report, generate_csv_report, generate_pdf_report");
}

/**
 * Generate Excel using existing service
 */
async function generateExcel(input: DocumentData): Promise<ExportResult> {
  const exportService = new ExcelExportService();

  // Prepare data in format expected by service
  const queryResult = {
    success: true,
    data: filterColumns(input.data, input.columns),
    metadata: {
      rowCount: input.data.length,
      hasMore: false,
      tables: ["export"],
      columns: input.columns || Object.keys(input.data[0] || {}),
    },
  };

  const result = await exportService.exportToExcel(queryResult, {
    options: {
      includeMetadata: input.includeMetadata ?? true,
      maxRows: 100000,
    },
  });

  return {
    ...result,
    filename: (input.filename || "census_export") + ".xlsx",
  };
}

/**
 * Generate CSV from data
 */
function generateCsv(input: DocumentData): string {
  const data = filterColumns(input.data, input.columns);
  if (data.length === 0) return "";

  const columns = input.columns || Object.keys(data[0]);

  // Header row
  const lines = [columns.map(escapeCSV).join(",")];

  // Data rows
  for (const row of data) {
    const values = columns.map((col) => escapeCSV(String(row[col] ?? "")));
    lines.push(values.join(","));
  }

  return lines.join("\n");
}

/**
 * Generate PDF report
 * Note: Uses simple text-based PDF. For complex layouts, consider pdfkit.
 */
async function generatePdf(input: DocumentData): Promise<ExportResult> {
  const exportService = new ExcelExportService();

  // Use Excel service's PDF generation if available, otherwise simple format
  const queryResult = {
    success: true,
    data: filterColumns(input.data, input.columns),
    metadata: {
      rowCount: input.data.length,
      hasMore: false,
      tables: ["export"],
      columns: input.columns || Object.keys(input.data[0] || {}),
    },
  };

  // ExcelExportService has exportToPDF method
  const result = await exportService.exportToPDF(queryResult, {
    options: {
      includeMetadata: true,
      maxRows: 100000,
    },
  });

  return {
    ...result,
    filename: (input.filename || "census_report") + ".pdf",
  };
}

/**
 * Filter data to only include specified columns
 */
function filterColumns(
  data: Record<string, unknown>[],
  columns?: string[]
): Record<string, unknown>[] {
  if (!columns || columns.length === 0) return data;

  return data.map((row) => {
    const filtered: Record<string, unknown> = {};
    for (const col of columns) {
      if (col in row) {
        filtered[col] = row[col];
      }
    }
    return filtered;
  });
}

/**
 * Escape value for CSV
 */
function escapeCSV(value: string): string {
  if (value.includes(",") || value.includes('"') || value.includes("\n")) {
    return `"${value.replace(/"/g, '""')}"`;
  }
  return value;
}
```
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/mcp/documentTools.ts` compiles
    - ExcelExportService import resolves
  </verify>
  <done>
    - generate_excel_report MCP tool registered
    - generate_csv_report MCP tool registered
    - generate_pdf_report MCP tool registered
    - Tools return base64-encoded content for transport
  </done>
</task>

<task type="auto">
  <name>Task 3: Register document tools and integrate session manager</name>
  <files>
    backend/src/mcp/mcpServer.ts
    backend/src/agent/agentService.ts
  </files>
  <action>
1. Update `backend/src/mcp/mcpServer.ts` to register document tools:

Add import near top:
```typescript
import { registerDocumentTools } from "./documentTools";
```

Find where tools are registered (after server.tool() calls for existing tools) and add:
```typescript
// Register document generation tools
registerDocumentTools(server);
```

2. Update allowed tools in `backend/src/agent/mcpConfig.ts`:

Update CENSUS_TOOLS constant:
```typescript
export const CENSUS_TOOLS = [
  "mcp__censuschat__execute_query",
  "mcp__censuschat__get_information_schema",
  "mcp__censuschat__validate_sql_query",
  "mcp__censuschat__generate_excel_report",
  "mcp__censuschat__generate_csv_report",
  "mcp__censuschat__generate_pdf_report",
] as const;
```

3. Update `backend/src/agent/agentService.ts` to use session manager:

Add import:
```typescript
import { getSessionManager } from "./sessionManager";
```

Update AgentService class constructor and query method:
```typescript
export class AgentService {
  private mcpServerUrl: string;
  private userId: string;
  private sessionManager = getSessionManager();

  constructor(mcpServerUrl?: string, userId?: string) {
    this.mcpServerUrl = mcpServerUrl || process.env.MCP_SERVER_URL || "http://localhost:3001/mcp";
    this.userId = userId || `anonymous-${Date.now()}`;
  }

  async query(prompt: string): Promise<AgentQueryResult<QueryResponse | ComparisonResponse>> {
    // Get existing session ID for this user (enables conversational context)
    const existingSessionId = this.sessionManager.getSessionIdForUser(this.userId);

    // Detect comparison queries and route appropriately
    if (isComparisonQuery(prompt)) {
      const result = await queryComparison(prompt, {
        mcpServerUrl: this.mcpServerUrl,
        sessionId: existingSessionId,
      });

      // Store new session ID for future queries
      if (result.sessionId) {
        this.sessionManager.storeSession(this.userId, result.sessionId, prompt, result.data);
      }

      return result as AgentQueryResult<QueryResponse | ComparisonResponse>;
    }

    // Standard query
    const result = await queryCensus(prompt, {
      mcpServerUrl: this.mcpServerUrl,
      sessionId: existingSessionId,
    });

    // Store session for conversational context
    if (result.sessionId) {
      this.sessionManager.storeSession(this.userId, result.sessionId, prompt, result.data);
    }

    return result;
  }

  getSessionId(): string | undefined {
    return this.sessionManager.getSessionIdForUser(this.userId);
  }

  clearSession(): void {
    this.sessionManager.clearUserSessions(this.userId);
  }
}
```

4. Update query.routes.ts to pass userId:

In the POST '/' handler where AgentService is instantiated:
```typescript
// Get userId from request (JWT user or session ID)
const userId = (req as any).user?.id || req.sessionID || `anon-${req.ip}`;
const agentService = new AgentService(undefined, userId);
```
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/mcp/mcpServer.ts` compiles
    - `npx tsc --noEmit backend/src/agent/agentService.ts` compiles
    - Document tools registered in MCP server startup logs
  </verify>
  <done>
    - Document tools registered on MCP server
    - Session manager tracks user sessions across queries
    - AgentService uses session manager for conversational context
    - Follow-up queries reference prior context via resume option
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd backend && npx tsc --noEmit` compiles without errors
2. File structure exists:
   - backend/src/agent/sessionManager.ts
   - backend/src/mcp/documentTools.ts
3. MCP server logs show: "Registered document generation tools"
4. CENSUS_TOOLS includes document generation tools
5. AgentService uses getSessionManager() for session tracking
</verification>

<success_criteria>
- Session manager tracks user-to-session mapping
- Document generation tools (Excel, CSV, PDF) registered on MCP server
- AgentService passes session ID to enable conversational context
- Tools use existing ExcelExportService for actual generation
- Follow-up queries can reference prior context
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-sdk-integration/04-03-SUMMARY.md`
</output>
