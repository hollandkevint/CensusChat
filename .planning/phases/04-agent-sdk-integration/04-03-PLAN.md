---
phase: 04-agent-sdk-integration
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/package.json
  - backend/src/agent/sessionManager.ts
  - backend/src/mcp/documentTools.ts
  - backend/src/mcp/mcpServer.ts
  - backend/src/agent/agentService.ts
autonomous: true

must_haves:
  truths:
    - "Conversational context persists across queries ('Now filter to income > $75K' references prior query)"
    - "Agent can generate Excel reports via MCP tool"
    - "Agent can generate PDF reports via MCP tool"
  artifacts:
    - path: "backend/src/agent/sessionManager.ts"
      provides: "Session tracking for conversational context"
      exports: ["AgentSessionManager", "getSessionManager"]
    - path: "backend/src/mcp/documentTools.ts"
      provides: "Excel and PDF generation MCP tools"
      exports: ["registerDocumentTools"]
  key_links:
    - from: "backend/src/mcp/documentTools.ts"
      to: "backend/src/services/excelExportService.ts"
      via: "import ExcelExportService"
      pattern: "ExcelExportService"
    - from: "backend/src/mcp/documentTools.ts"
      to: "pdfkit"
      via: "import PDFDocument"
      pattern: "PDFDocument.*from.*pdfkit"
    - from: "backend/src/mcp/mcpServer.ts"
      to: "backend/src/mcp/documentTools.ts"
      via: "registerDocumentTools(server)"
      pattern: "registerDocumentTools"
    - from: "backend/src/agent/agentService.ts"
      to: "backend/src/agent/sessionManager.ts"
      via: "import getSessionManager"
      pattern: "getSessionManager"
---

<objective>
Add conversational session memory and document generation MCP tools for Excel/PDF reports.

Purpose: Enable follow-up queries that reference prior context and allow agent to generate structured documents.
Output: Session manager for context persistence, MCP tools wrapping existing Excel service and new PDF generation.
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-agent-sdk-integration/04-RESEARCH.md
@.planning/phases/04-agent-sdk-integration/04-01-SUMMARY.md
@backend/src/agent/agentService.ts
@backend/src/services/excelExportService.ts
@backend/src/models/export.models.ts
@backend/src/mcp/mcpServer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session manager for conversational context</name>
  <files>
    backend/src/agent/sessionManager.ts
  </files>
  <action>
Create `backend/src/agent/sessionManager.ts` for tracking conversation sessions:

```typescript
/**
 * Agent Session Manager
 * Tracks session IDs from Agent SDK for conversational context persistence
 * Enables follow-up queries like "Now filter to income > $75K" that reference prior context
 */

export interface SessionContext {
  sessionId: string;
  userId?: string;
  createdAt: Date;
  lastAccessedAt: Date;
  queryCount: number;
  lastQuery?: string;
  lastResult?: unknown;
}

/**
 * In-memory session manager
 * For production, consider Redis persistence
 */
export class AgentSessionManager {
  private sessions: Map<string, SessionContext> = new Map();
  private userToSession: Map<string, string> = new Map();
  private maxSessions: number;
  private sessionTTLMs: number;

  constructor(options?: { maxSessions?: number; sessionTTLMs?: number }) {
    this.maxSessions = options?.maxSessions || 1000;
    this.sessionTTLMs = options?.sessionTTLMs || 30 * 60 * 1000; // 30 minutes default
  }

  /**
   * Get or create session for a user
   * Returns existing session ID if user has active session
   */
  getOrCreateSession(userId: string): string {
    // Check for existing session
    const existingSessionId = this.userToSession.get(userId);
    if (existingSessionId) {
      const session = this.sessions.get(existingSessionId);
      if (session && !this.isExpired(session)) {
        session.lastAccessedAt = new Date();
        return existingSessionId;
      }
      // Expired, clean up
      this.deleteSession(existingSessionId);
    }

    // No session yet - return empty string, will be set after first query
    return "";
  }

  /**
   * Store session ID from Agent SDK response
   */
  storeSession(userId: string, sessionId: string, query?: string, result?: unknown): void {
    // Clean up old sessions if at capacity
    if (this.sessions.size >= this.maxSessions) {
      this.cleanupOldestSessions();
    }

    const now = new Date();
    const existing = this.sessions.get(sessionId);

    if (existing) {
      existing.lastAccessedAt = now;
      existing.queryCount++;
      existing.lastQuery = query;
      existing.lastResult = result;
    } else {
      this.sessions.set(sessionId, {
        sessionId,
        userId,
        createdAt: now,
        lastAccessedAt: now,
        queryCount: 1,
        lastQuery: query,
        lastResult: result,
      });
      this.userToSession.set(userId, sessionId);
    }
  }

  /**
   * Get session context
   */
  getSession(sessionId: string): SessionContext | undefined {
    const session = this.sessions.get(sessionId);
    if (session && !this.isExpired(session)) {
      return session;
    }
    return undefined;
  }

  /**
   * Get session ID for user
   */
  getSessionIdForUser(userId: string): string | undefined {
    const sessionId = this.userToSession.get(userId);
    if (sessionId) {
      const session = this.sessions.get(sessionId);
      if (session && !this.isExpired(session)) {
        return sessionId;
      }
    }
    return undefined;
  }

  /**
   * Delete a session
   */
  deleteSession(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session?.userId) {
      this.userToSession.delete(session.userId);
    }
    this.sessions.delete(sessionId);
  }

  /**
   * Clear all sessions for a user (logout)
   */
  clearUserSessions(userId: string): void {
    const sessionId = this.userToSession.get(userId);
    if (sessionId) {
      this.deleteSession(sessionId);
    }
  }

  /**
   * Get session stats
   */
  getStats(): { activeSessions: number; totalQueries: number } {
    let totalQueries = 0;
    for (const session of this.sessions.values()) {
      if (!this.isExpired(session)) {
        totalQueries += session.queryCount;
      }
    }
    return {
      activeSessions: this.sessions.size,
      totalQueries,
    };
  }

  private isExpired(session: SessionContext): boolean {
    return Date.now() - session.lastAccessedAt.getTime() > this.sessionTTLMs;
  }

  private cleanupOldestSessions(): void {
    const sorted = [...this.sessions.entries()].sort(
      (a, b) => a[1].lastAccessedAt.getTime() - b[1].lastAccessedAt.getTime()
    );
    // Remove oldest 10%
    const toRemove = Math.ceil(sorted.length * 0.1);
    for (let i = 0; i < toRemove; i++) {
      this.deleteSession(sorted[i][0]);
    }
  }
}

// Singleton instance
let sessionManagerInstance: AgentSessionManager | null = null;

export function getSessionManager(): AgentSessionManager {
  if (!sessionManagerInstance) {
    sessionManagerInstance = new AgentSessionManager();
  }
  return sessionManagerInstance;
}
```
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/agent/sessionManager.ts` compiles
  </verify>
  <done>
    - AgentSessionManager tracks user-to-session mapping
    - Sessions auto-expire after 30 minutes
    - getSessionManager() returns singleton
  </done>
</task>

<task type="auto">
  <name>Task 2: Create document generation MCP tools</name>
  <files>
    backend/package.json
    backend/src/mcp/documentTools.ts
  </files>
  <action>
1. Install pdfkit for PDF generation:
   ```bash
   cd backend && npm install pdfkit @types/pdfkit
   ```

2. Create `backend/src/mcp/documentTools.ts` wrapping existing Excel service and implementing PDF directly:

```typescript
/**
 * Document Generation MCP Tools
 * Wraps existing ExcelExportService for Excel and implements PDF with pdfkit
 * Agent SDK uses these tools for "generate Excel report" / "create PDF" requests
 *
 * IMPORTANT: ExcelExportService has only exportToExcel() - NO exportToPDF() method.
 * PDF generation is implemented directly using pdfkit in this file.
 */
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { ExcelExportService } from "../services/excelExportService";
import { ExportResponse, QueryResultForExport } from "../models/export.models";
import { z } from "zod";
import PDFDocument from "pdfkit";

// Schema for document generation input
const DocumentDataSchema = z.object({
  data: z.array(z.record(z.string(), z.unknown())),
  filename: z.string().optional(),
  title: z.string().optional(),
  includeMetadata: z.boolean().optional(),
  columns: z.array(z.string()).optional(),
});

type DocumentData = z.infer<typeof DocumentDataSchema>;

// Result type for document generation (internal use)
interface DocumentResult {
  filename: string;
  mimeType: string;
  size: number;
  buffer: Buffer;
}

/**
 * Register document generation tools on MCP server
 */
export function registerDocumentTools(server: Server): void {
  // Excel generation tool
  server.tool(
    "generate_excel_report",
    "Generate an Excel spreadsheet from query results. Returns base64-encoded file content.",
    {
      data: {
        type: "array",
        items: { type: "object", additionalProperties: true },
        description: "Array of data records to include in the spreadsheet",
      },
      filename: {
        type: "string",
        description: "Optional filename (without extension)",
      },
      title: {
        type: "string",
        description: "Optional title for the report",
      },
      includeMetadata: {
        type: "boolean",
        description: "Whether to include metadata row (default: true)",
      },
      columns: {
        type: "array",
        items: { type: "string" },
        description: "Optional list of columns to include (default: all)",
      },
    },
    async (args) => {
      try {
        const input = DocumentDataSchema.parse(args);
        const result = await generateExcel(input);

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: true,
                filename: result.filename,
                mimeType: result.mimeType,
                size: result.size,
                // Base64 encode the buffer for transport
                content: result.buffer.toString("base64"),
              }),
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: false,
                error: error instanceof Error ? error.message : "Excel generation failed",
              }),
            },
          ],
          isError: true,
        };
      }
    }
  );

  // CSV generation tool (simpler alternative)
  server.tool(
    "generate_csv_report",
    "Generate a CSV file from query results. Returns the CSV content as text.",
    {
      data: {
        type: "array",
        items: { type: "object", additionalProperties: true },
        description: "Array of data records to include",
      },
      filename: {
        type: "string",
        description: "Optional filename (without extension)",
      },
      columns: {
        type: "array",
        items: { type: "string" },
        description: "Optional list of columns to include (default: all)",
      },
    },
    async (args) => {
      try {
        const input = DocumentDataSchema.parse(args);
        const csv = generateCsv(input);

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: true,
                filename: (input.filename || "export") + ".csv",
                mimeType: "text/csv",
                content: csv,
              }),
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: false,
                error: error instanceof Error ? error.message : "CSV generation failed",
              }),
            },
          ],
          isError: true,
        };
      }
    }
  );

  // PDF generation tool
  server.tool(
    "generate_pdf_report",
    "Generate a PDF report from query results. Returns base64-encoded file content.",
    {
      data: {
        type: "array",
        items: { type: "object", additionalProperties: true },
        description: "Array of data records to include",
      },
      title: {
        type: "string",
        description: "Report title",
      },
      filename: {
        type: "string",
        description: "Optional filename (without extension)",
      },
      columns: {
        type: "array",
        items: { type: "string" },
        description: "Optional list of columns to include (default: all)",
      },
    },
    async (args) => {
      try {
        const input = DocumentDataSchema.parse(args);
        const result = await generatePdf(input);

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: true,
                filename: result.filename,
                mimeType: result.mimeType,
                size: result.size,
                content: result.buffer.toString("base64"),
              }),
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: false,
                error: error instanceof Error ? error.message : "PDF generation failed",
              }),
            },
          ],
          isError: true,
        };
      }
    }
  );

  console.log("[MCP] Registered document generation tools: generate_excel_report, generate_csv_report, generate_pdf_report");
}

/**
 * Generate Excel using existing ExcelExportService
 * Note: This service only has exportToExcel(), not exportToPDF()
 */
async function generateExcel(input: DocumentData): Promise<DocumentResult> {
  const exportService = new ExcelExportService();

  // Prepare data in format expected by ExcelExportService
  const queryResult: QueryResultForExport = {
    success: true,
    message: "Export data",
    data: filterColumns(input.data, input.columns),
    metadata: {
      queryTime: 0,
      totalRecords: input.data.length,
      dataSource: "MCP Export",
      confidenceLevel: 1.0,
      marginOfError: 0,
      queryText: input.title || "Export",
      executedAt: new Date().toISOString(),
    },
  };

  const response: ExportResponse = await exportService.exportToExcel(queryResult, {
    queryId: `export-${Date.now()}`,
    format: "excel",
    options: {
      includeMetadata: input.includeMetadata ?? true,
      compression: false,
      maxRows: 100000,
      customFilename: input.filename,
    },
  });

  // ExportResponse returns downloadUrl, not buffer directly
  // For MCP tool, we need to read the file and return buffer
  // The service writes to temp dir, we need to fetch it
  const exportFile = await exportService.getExportFile(response.exportId);
  if (!exportFile) {
    throw new Error("Failed to retrieve generated Excel file");
  }

  const fs = await import("fs");
  const buffer = fs.readFileSync(exportFile.filePath);

  return {
    filename: (input.filename || "census_export") + ".xlsx",
    mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    size: buffer.length,
    buffer,
  };
}

/**
 * Generate CSV from data
 */
function generateCsv(input: DocumentData): string {
  const data = filterColumns(input.data, input.columns);
  if (data.length === 0) return "";

  const columns = input.columns || Object.keys(data[0]);

  // Header row
  const lines = [columns.map(escapeCSV).join(",")];

  // Data rows
  for (const row of data) {
    const values = columns.map((col) => escapeCSV(String(row[col] ?? "")));
    lines.push(values.join(","));
  }

  return lines.join("\n");
}

/**
 * Generate PDF report using pdfkit directly
 * IMPORTANT: ExcelExportService does NOT have exportToPDF() - we implement it here
 */
async function generatePdf(input: DocumentData): Promise<DocumentResult> {
  return new Promise((resolve, reject) => {
    try {
      const data = filterColumns(input.data, input.columns);
      const columns = input.columns || (data.length > 0 ? Object.keys(data[0]) : []);

      // Create PDF document
      const doc = new PDFDocument({
        size: "A4",
        margin: 50,
        bufferPages: true,
      });

      // Collect buffer chunks
      const chunks: Buffer[] = [];
      doc.on("data", (chunk: Buffer) => chunks.push(chunk));
      doc.on("end", () => {
        const buffer = Buffer.concat(chunks);
        resolve({
          filename: (input.filename || "census_report") + ".pdf",
          mimeType: "application/pdf",
          size: buffer.length,
          buffer,
        });
      });
      doc.on("error", reject);

      // Title
      doc
        .fontSize(20)
        .font("Helvetica-Bold")
        .text(input.title || "Census Data Report", { align: "center" });

      doc.moveDown();

      // Metadata
      doc
        .fontSize(10)
        .font("Helvetica")
        .text(`Generated: ${new Date().toLocaleString()}`, { align: "right" })
        .text(`Total Records: ${data.length}`, { align: "right" });

      doc.moveDown(2);

      // Table header
      if (columns.length > 0) {
        const colWidth = (doc.page.width - 100) / Math.min(columns.length, 5);
        let y = doc.y;

        // Draw header row
        doc.font("Helvetica-Bold").fontSize(9);
        columns.slice(0, 5).forEach((col, i) => {
          doc.text(
            truncateText(String(col), 15),
            50 + i * colWidth,
            y,
            { width: colWidth - 5, align: "left" }
          );
        });

        doc.moveDown();
        y = doc.y;

        // Draw header line
        doc
          .moveTo(50, y)
          .lineTo(doc.page.width - 50, y)
          .stroke();

        doc.moveDown(0.5);

        // Draw data rows
        doc.font("Helvetica").fontSize(8);

        const maxRows = 50; // Limit rows per page for readability
        const displayData = data.slice(0, maxRows);

        for (const row of displayData) {
          y = doc.y;

          // Check for page break
          if (y > doc.page.height - 100) {
            doc.addPage();
            y = 50;
          }

          columns.slice(0, 5).forEach((col, i) => {
            const value = row[col];
            const displayValue = value === null || value === undefined
              ? ""
              : typeof value === "number"
                ? value.toLocaleString()
                : String(value);

            doc.text(
              truncateText(displayValue, 20),
              50 + i * colWidth,
              y,
              { width: colWidth - 5, align: "left" }
            );
          });

          doc.moveDown(0.8);
        }

        // Note if truncated
        if (data.length > maxRows) {
          doc.moveDown();
          doc
            .font("Helvetica-Oblique")
            .fontSize(9)
            .text(`... and ${data.length - maxRows} more records (truncated for display)`);
        }
      } else {
        doc.text("No data available");
      }

      // Footer
      const pageCount = doc.bufferedPageRange().count;
      for (let i = 0; i < pageCount; i++) {
        doc.switchToPage(i);
        doc
          .fontSize(8)
          .text(
            `Page ${i + 1} of ${pageCount}`,
            50,
            doc.page.height - 50,
            { align: "center" }
          );
      }

      // Finalize
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Filter data to only include specified columns
 */
function filterColumns(
  data: Record<string, unknown>[],
  columns?: string[]
): Record<string, unknown>[] {
  if (!columns || columns.length === 0) return data;

  return data.map((row) => {
    const filtered: Record<string, unknown> = {};
    for (const col of columns) {
      if (col in row) {
        filtered[col] = row[col];
      }
    }
    return filtered;
  });
}

/**
 * Escape value for CSV
 */
function escapeCSV(value: string): string {
  if (value.includes(",") || value.includes('"') || value.includes("\n")) {
    return `"${value.replace(/"/g, '""')}"`;
  }
  return value;
}

/**
 * Truncate text for PDF display
 */
function truncateText(text: string, maxLen: number): string {
  if (text.length <= maxLen) return text;
  return text.substring(0, maxLen - 1) + "...";
}
```

Key design decisions:
- Excel: Wraps existing ExcelExportService.exportToExcel() correctly
- PDF: Implemented directly with pdfkit (ExcelExportService does NOT have exportToPDF)
- CSV: Simple implementation for lightweight exports
- Uses ExportResponse from export.models.ts (not a non-existent ExportResult type)
- All tools return base64-encoded content for MCP transport
  </action>
  <verify>
    - `npm ls pdfkit` shows installed version
    - `npx tsc --noEmit backend/src/mcp/documentTools.ts` compiles
    - ExcelExportService import resolves
    - PDFDocument import resolves from pdfkit
  </verify>
  <done>
    - generate_excel_report MCP tool registered (uses ExcelExportService.exportToExcel)
    - generate_csv_report MCP tool registered
    - generate_pdf_report MCP tool registered (uses pdfkit directly, NOT a non-existent exportToPDF)
    - Tools return base64-encoded content for transport
  </done>
</task>

<task type="auto">
  <name>Task 3: Register document tools and integrate session manager</name>
  <files>
    backend/src/mcp/mcpServer.ts
    backend/src/agent/agentService.ts
    backend/src/agent/mcpConfig.ts
  </files>
  <action>
1. Update `backend/src/mcp/mcpServer.ts` to register document tools:

Add import near top:
```typescript
import { registerDocumentTools } from "./documentTools";
```

Find where tools are registered (after server.tool() calls for existing tools) and add:
```typescript
// Register document generation tools
registerDocumentTools(server);
```

2. Update allowed tools in `backend/src/agent/mcpConfig.ts`:

Update CENSUS_TOOLS constant:
```typescript
export const CENSUS_TOOLS = [
  "mcp__censuschat__execute_query",
  "mcp__censuschat__get_information_schema",
  "mcp__censuschat__validate_sql_query",
  "mcp__censuschat__generate_excel_report",
  "mcp__censuschat__generate_csv_report",
  "mcp__censuschat__generate_pdf_report",
] as const;
```

3. Update `backend/src/agent/agentService.ts` to use session manager:

Add import:
```typescript
import { getSessionManager } from "./sessionManager";
```

Update AgentService class to track sessions:
```typescript
/**
 * AgentService class for stateful usage with session management
 */
export class AgentService {
  private model: string;
  private systemPrompt?: string;
  private userId: string;
  private sessionManager = getSessionManager();

  constructor(options?: { model?: string; systemPrompt?: string; userId?: string }) {
    this.model = options?.model || "claude-sonnet-4-20250514";
    this.systemPrompt = options?.systemPrompt;
    this.userId = options?.userId || `anonymous-${Date.now()}`;
  }

  async query(prompt: string): Promise<AgentQueryResult<QueryResponse | ComparisonResponse>> {
    // Detect comparison queries and route appropriately
    if (isComparisonQuery(prompt)) {
      const result = await queryComparison(prompt, {
        model: this.model,
      });

      // Store session for conversational context
      if (result.success) {
        this.sessionManager.storeSession(this.userId, `session-${Date.now()}`, prompt, result.data);
      }

      return result as AgentQueryResult<QueryResponse | ComparisonResponse>;
    }

    // Standard query
    const result = await queryCensus(prompt, {
      model: this.model,
      systemPrompt: this.systemPrompt,
    });

    // Store session for conversational context
    if (result.success) {
      this.sessionManager.storeSession(this.userId, `session-${Date.now()}`, prompt, result.data);
    }

    return result;
  }

  async queryWithSchema<T extends z.ZodType>(
    prompt: string,
    schema: T
  ): Promise<AgentQueryResult<z.infer<T>>> {
    return queryWithSchema(prompt, schema, {
      model: this.model,
      systemPrompt: this.systemPrompt,
    });
  }

  getSessionId(): string | undefined {
    return this.sessionManager.getSessionIdForUser(this.userId);
  }

  clearSession(): void {
    this.sessionManager.clearUserSessions(this.userId);
  }
}
```

4. Update query.routes.ts to pass userId:

In the POST '/' handler where AgentService is instantiated:
```typescript
// Get userId from request (JWT user or session ID)
const userId = (req as any).user?.id || req.sessionID || `anon-${req.ip}`;
const agentService = new AgentService({ userId });
```
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/mcp/mcpServer.ts` compiles
    - `npx tsc --noEmit backend/src/agent/agentService.ts` compiles
    - Document tools registered in MCP server startup logs
  </verify>
  <done>
    - Document tools registered on MCP server
    - Session manager tracks user sessions across queries
    - AgentService uses session manager for conversational context
    - CENSUS_TOOLS includes document generation tools
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd backend && npm ls pdfkit` shows installed package
2. `cd backend && npx tsc --noEmit` compiles without errors
3. File structure exists:
   - backend/src/agent/sessionManager.ts
   - backend/src/mcp/documentTools.ts
4. MCP server logs show: "Registered document generation tools"
5. CENSUS_TOOLS includes document generation tools
6. AgentService uses getSessionManager() for session tracking
</verification>

<success_criteria>
- Session manager tracks user-to-session mapping
- Document generation tools (Excel, CSV, PDF) registered on MCP server
- Excel uses ExcelExportService.exportToExcel() (existing service)
- PDF uses pdfkit directly (NOT a non-existent exportToPDF method)
- AgentService tracks sessions for conversational context
- Tools use correct types (ExportResponse from export.models.ts)
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-sdk-integration/04-03-SUMMARY.md`
</output>
