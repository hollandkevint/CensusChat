---
phase: 04-agent-sdk-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/src/agent/agents/regionAnalyzer.ts
  - backend/src/agent/agents/index.ts
  - backend/src/agent/mcpConfig.ts
  - backend/src/routes/query.routes.ts
autonomous: true

must_haves:
  truths:
    - "User can say 'Compare Tampa Bay vs Phoenix' and get parallel results"
    - "Agent queries route through existing MCP HTTP server"
    - "Query route uses agentService instead of direct anthropicService"
  artifacts:
    - path: "backend/src/agent/agents/regionAnalyzer.ts"
      provides: "Subagent definition for parallel region analysis"
      exports: ["regionAnalyzerAgent"]
    - path: "backend/src/agent/mcpConfig.ts"
      provides: "MCP server connection configuration"
      exports: ["getMcpConfig"]
    - path: "backend/src/routes/query.routes.ts"
      provides: "Query endpoint using AgentService"
      contains: "AgentService"
  key_links:
    - from: "backend/src/routes/query.routes.ts"
      to: "backend/src/agent/agentService.ts"
      via: "import AgentService"
      pattern: "import.*AgentService.*from.*agent"
    - from: "backend/src/agent/agents/regionAnalyzer.ts"
      to: "@anthropic-ai/claude-agent-sdk"
      via: "AgentDefinition type"
      pattern: "AgentDefinition"
---

<objective>
Wire Agent SDK to existing MCP HTTP server and implement multi-region comparison via subagents.

Purpose: Enable parallel region analysis (e.g., "Compare Tampa vs Phoenix") using Agent SDK's Task tool for subagent orchestration.
Output: Query routes use AgentService, regionAnalyzer subagent handles parallel comparisons.
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-agent-sdk-integration/04-RESEARCH.md
@.planning/phases/04-agent-sdk-integration/04-01-SUMMARY.md
@backend/src/agent/agentService.ts
@backend/src/routes/query.routes.ts
@backend/src/mcp/mcpClient.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP config and region analyzer subagent</name>
  <files>
    backend/src/agent/mcpConfig.ts
    backend/src/agent/agents/regionAnalyzer.ts
    backend/src/agent/agents/index.ts
  </files>
  <action>
1. Create `backend/src/agent/mcpConfig.ts` for centralized MCP configuration:

```typescript
/**
 * MCP Server Configuration for Agent SDK
 * Centralized config for connecting to CensusChat MCP server
 */

export interface McpServerConfig {
  type: "http";
  url: string;
  headers?: Record<string, string>;
}

export interface McpServersConfig {
  censuschat: McpServerConfig;
}

/**
 * Get MCP server configuration
 * Uses environment variable or defaults to localhost
 */
export function getMcpConfig(): McpServersConfig {
  const baseUrl = process.env.MCP_SERVER_URL || "http://localhost:3001";

  return {
    censuschat: {
      type: "http",
      url: `${baseUrl}/mcp`,
    },
  };
}

/**
 * List of allowed MCP tools for census queries
 */
export const CENSUS_TOOLS = [
  "mcp__censuschat__execute_query",
  "mcp__censuschat__get_information_schema",
  "mcp__censuschat__validate_sql_query",
] as const;
```

2. Create `backend/src/agent/agents/regionAnalyzer.ts` with subagent definition:

```typescript
/**
 * Region Analyzer Subagent
 * Specialized agent for analyzing demographic data in a specific region
 * Used by main agent via Task tool for parallel region comparisons
 */
import { AgentDefinition } from "@anthropic-ai/claude-agent-sdk";
import { CENSUS_TOOLS } from "../mcpConfig";

/**
 * Subagent for analyzing a single region
 * Main agent spawns multiple instances for parallel comparison
 */
export const regionAnalyzerAgent: AgentDefinition = {
  description: "Analyzes demographic data for a specific geographic region using Census data",
  prompt: `You are a census data analyst specializing in regional demographics.

When given a region (city, county, or metro area), you will:
1. Query the census database for key demographic metrics
2. Focus on: population, age distribution (especially 65+), income levels, and healthcare access indicators
3. Return structured data suitable for comparison

Use the execute_query tool to run SQL queries against the census database.
Available tables: county_data, block_group_data_expanded

For city/metro area queries, search by county_name patterns (e.g., "Tampa" matches counties in Tampa Bay area).

Always return results in a structured format with:
- region_name: The region analyzed
- total_population: Total population
- seniors_65_plus: Population aged 65+
- median_income: Median household income
- key_metrics: Object with additional relevant metrics`,
  tools: [...CENSUS_TOOLS],
  model: "sonnet", // Use Sonnet for subagent efficiency
};

/**
 * Schema for region analysis results (used in comparisons)
 */
export const RegionAnalysisResultSchema = {
  type: "object",
  properties: {
    region_name: { type: "string" },
    total_population: { type: "number" },
    seniors_65_plus: { type: "number" },
    median_income: { type: "number" },
    key_metrics: {
      type: "object",
      additionalProperties: true,
    },
  },
  required: ["region_name", "total_population"],
};
```

3. Create `backend/src/agent/agents/index.ts` barrel export:

```typescript
export * from "./regionAnalyzer";
```
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/agent/agents/regionAnalyzer.ts` compiles
    - AgentDefinition type import resolves from SDK
  </verify>
  <done>
    - regionAnalyzerAgent exported with proper AgentDefinition structure
    - MCP config centralized in mcpConfig.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comparison query support to agentService</name>
  <files>
    backend/src/agent/agentService.ts
  </files>
  <action>
Extend `backend/src/agent/agentService.ts` to support multi-region comparisons:

Add the following to the existing file:

```typescript
// Add imports at top
import { regionAnalyzerAgent } from "./agents";
import { getMcpConfig, CENSUS_TOOLS } from "./mcpConfig";

// Add comparison schema
export const ComparisonResponseSchema = z.object({
  success: z.boolean(),
  comparison: z.object({
    regions: z.array(z.object({
      region_name: z.string(),
      total_population: z.number(),
      seniors_65_plus: z.number().optional(),
      median_income: z.number().optional(),
      key_metrics: z.record(z.string(), z.unknown()).optional(),
    })),
    summary: z.string(),
    differences: z.array(z.string()).optional(),
  }),
  explanation: z.string(),
});

export type ComparisonResponse = z.infer<typeof ComparisonResponseSchema>;

/**
 * Compare multiple regions using parallel subagents
 * Example: "Compare Tampa Bay vs Phoenix for Medicare eligible population"
 */
export async function queryComparison(
  prompt: string,
  options: AgentQueryOptions = {}
): Promise<AgentQueryResult<ComparisonResponse>> {
  const mcpConfig = getMcpConfig();
  let result: AgentQueryResult<ComparisonResponse> = { success: false };
  let capturedSessionId: string | undefined;

  try {
    for await (const message of query({
      prompt: `Analyze and compare regions mentioned in this query: "${prompt}"

Use the region-analyzer subagent for each region to gather data in parallel.
Then synthesize the results into a comparison.`,
      options: {
        mcpServers: mcpConfig,
        allowedTools: [...CENSUS_TOOLS, "Task"],
        agents: {
          "region-analyzer": regionAnalyzerAgent,
        },
        outputFormat: {
          type: "json_schema",
          schema: z.toJSONSchema(ComparisonResponseSchema),
        },
        ...(options.sessionId && { resume: options.sessionId }),
        permissionMode: "acceptEdits",
      },
    })) {
      if (message.type === "system" && message.subtype === "init") {
        capturedSessionId = message.session_id;
      }

      if (message.type === "result" && message.subtype === "success") {
        if (message.structured_output) {
          const parsed = ComparisonResponseSchema.safeParse(message.structured_output);
          if (parsed.success) {
            result = {
              success: true,
              data: parsed.data,
              sessionId: capturedSessionId,
            };
          } else {
            result = {
              success: false,
              error: `Comparison schema validation failed: ${parsed.error.message}`,
              sessionId: capturedSessionId,
            };
          }
        }
      }

      if (message.type === "result" && message.subtype === "error") {
        result = {
          success: false,
          error: message.error || "Comparison query failed",
          sessionId: capturedSessionId,
        };
      }
    }
  } catch (error) {
    result = {
      success: false,
      error: error instanceof Error ? error.message : "Unknown comparison error",
    };
  }

  return result;
}

/**
 * Detect if a query is a comparison request
 */
export function isComparisonQuery(prompt: string): boolean {
  const comparisonPatterns = [
    /\bcompare\b/i,
    /\bvs\.?\b/i,
    /\bversus\b/i,
    /\bdifference between\b/i,
    /\bhow does.*compare\b/i,
    /\bwhich.*better\b/i,
  ];
  return comparisonPatterns.some(pattern => pattern.test(prompt));
}
```

Update the existing AgentService class to handle comparisons:

```typescript
// In AgentService class, update the query method:
async query(prompt: string): Promise<AgentQueryResult<QueryResponse | ComparisonResponse>> {
  // Detect comparison queries and route appropriately
  if (isComparisonQuery(prompt)) {
    const result = await queryComparison(prompt, {
      mcpServerUrl: this.mcpServerUrl,
      sessionId: this.sessionId,
    });
    if (result.sessionId) {
      this.sessionId = result.sessionId;
    }
    return result as AgentQueryResult<QueryResponse | ComparisonResponse>;
  }

  // Standard query
  const result = await queryCensus(prompt, {
    mcpServerUrl: this.mcpServerUrl,
    sessionId: this.sessionId,
  });
  if (result.sessionId) {
    this.sessionId = result.sessionId;
  }
  return result;
}
```
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/agent/agentService.ts` compiles
    - isComparisonQuery("Compare Tampa vs Phoenix") returns true
    - isComparisonQuery("Show seniors in Florida") returns false
  </verify>
  <done>
    - queryComparison() uses Task tool with region-analyzer subagent
    - AgentService.query() auto-detects comparison queries
    - ComparisonResponseSchema defined and exported
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire query routes to use AgentService</name>
  <files>
    backend/src/routes/query.routes.ts
  </files>
  <action>
Update `backend/src/routes/query.routes.ts` to use AgentService alongside existing flow:

1. Add imports at top:
```typescript
import { AgentService, isComparisonQuery } from '../agent/agentService';
```

2. Add feature flag near other flags:
```typescript
// Feature flag for Agent SDK usage (gradual rollout)
const USE_AGENT_SDK = process.env.USE_AGENT_SDK === 'true';
```

3. In the POST '/' handler, add Agent SDK path before existing flow:

Find the `processQuery` async function and add this at the beginning, before Step 0:

```typescript
// Agent SDK path (opt-in via feature flag)
if (USE_AGENT_SDK) {
  console.log('ü§ñ Using Agent SDK for query processing...');

  // Get or create agent service (could be per-request or singleton)
  const agentService = new AgentService();

  const agentResult = await agentService.query(preprocessedQuery);

  if (agentResult.success && agentResult.data) {
    const queryTime = (Date.now() - startTime) / 1000;

    // Handle comparison responses
    if ('comparison' in agentResult.data) {
      return {
        success: true,
        message: `Comparison complete for ${agentResult.data.comparison.regions.length} regions`,
        data: agentResult.data.comparison.regions,
        comparison: agentResult.data.comparison,
        metadata: {
          queryTime,
          totalRecords: agentResult.data.comparison.regions.length,
          dataSource: 'Agent SDK with MCP',
          confidenceLevel: 0.95,
          usedAgentSDK: true,
          sessionId: agentResult.sessionId,
          analysis: { explanation: agentResult.data.explanation },
        },
      };
    }

    // Handle standard query responses
    return {
      success: true,
      message: `Found ${agentResult.data.metadata.rowCount} records`,
      data: agentResult.data.data,
      metadata: {
        queryTime,
        totalRecords: agentResult.data.metadata.rowCount,
        dataSource: 'Agent SDK with MCP',
        confidenceLevel: 0.95,
        usedAgentSDK: true,
        sessionId: agentResult.sessionId,
        analysis: {
          explanation: agentResult.data.explanation,
          suggestedRefinements: agentResult.data.suggestedRefinements,
        },
      },
    };
  } else {
    console.warn('‚ö†Ô∏è Agent SDK query failed, falling back to standard flow:', agentResult.error);
    // Fall through to standard processing below
  }
}
```

Note: This is additive - existing anthropicService + MCP flow remains as fallback.
The feature flag allows gradual rollout and easy rollback.
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/routes/query.routes.ts` compiles
    - With USE_AGENT_SDK=false, existing flow unchanged
    - Imports resolve correctly
  </verify>
  <done>
    - query.routes.ts imports AgentService
    - Feature flag USE_AGENT_SDK controls opt-in
    - Comparison queries return regions array with comparison metadata
    - Fallback to existing flow on Agent SDK failure
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd backend && npx tsc --noEmit` compiles without errors
2. File structure exists:
   - backend/src/agent/mcpConfig.ts
   - backend/src/agent/agents/regionAnalyzer.ts
   - backend/src/agent/agents/index.ts
3. query.routes.ts contains AgentService import
4. isComparisonQuery() correctly detects comparison patterns
</verification>

<success_criteria>
- MCP config centralized and importable
- regionAnalyzer subagent defined with proper AgentDefinition
- AgentService.query() handles both standard and comparison queries
- query.routes.ts integrates AgentService with feature flag
- Comparison queries detected and routed to queryComparison()
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-sdk-integration/04-02-SUMMARY.md`
</output>
