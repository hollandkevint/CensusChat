---
phase: 04-agent-sdk-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/src/agent/agents/regionAnalyzer.ts
  - backend/src/agent/agents/index.ts
  - backend/src/agent/mcpConfig.ts
  - backend/src/routes/query.routes.ts
  - backend/src/agent/agentService.ts
autonomous: true

must_haves:
  truths:
    - "User can say 'Compare Tampa Bay vs Phoenix' and get parallel results"
    - "Agent queries route through existing MCP HTTP server"
    - "Query route uses agentService instead of direct anthropicService"
  artifacts:
    - path: "backend/src/agent/agents/regionAnalyzer.ts"
      provides: "Region analyzer agent configuration"
      exports: ["regionAnalyzerConfig", "RegionAnalysisResultSchema"]
    - path: "backend/src/agent/mcpConfig.ts"
      provides: "MCP server connection configuration"
      exports: ["getMcpConfig"]
    - path: "backend/src/routes/query.routes.ts"
      provides: "Query endpoint using AgentService"
      contains: "AgentService"
  key_links:
    - from: "backend/src/routes/query.routes.ts"
      to: "backend/src/agent/agentService.ts"
      via: "import AgentService"
      pattern: "import.*AgentService.*from.*agent"
    - from: "backend/src/agent/agentService.ts"
      to: "zod-to-json-schema"
      via: "import zodToJsonSchema"
      pattern: "zodToJsonSchema"
---

<objective>
Wire Agent SDK to existing MCP HTTP server and implement multi-region comparison.

Purpose: Enable parallel region analysis (e.g., "Compare Tampa vs Phoenix") using the AgentService with structured outputs.
Output: Query routes use AgentService, regionAnalyzer configuration handles parallel comparisons.
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-agent-sdk-integration/04-RESEARCH.md
@.planning/phases/04-agent-sdk-integration/04-01-SUMMARY.md
@backend/src/agent/agentService.ts
@backend/src/routes/query.routes.ts
@backend/src/mcp/mcpClient.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP config and region analyzer configuration</name>
  <files>
    backend/src/agent/mcpConfig.ts
    backend/src/agent/agents/regionAnalyzer.ts
    backend/src/agent/agents/index.ts
  </files>
  <action>
1. Create `backend/src/agent/mcpConfig.ts` for centralized MCP configuration:

```typescript
/**
 * MCP Server Configuration for Agent SDK
 * Centralized config for connecting to CensusChat MCP server
 */

export interface McpServerConfig {
  type: "http";
  url: string;
  headers?: Record<string, string>;
}

export interface McpServersConfig {
  censuschat: McpServerConfig;
}

/**
 * Get MCP server configuration
 * Uses environment variable or defaults to localhost
 */
export function getMcpConfig(): McpServersConfig {
  const baseUrl = process.env.MCP_SERVER_URL || "http://localhost:3001";

  return {
    censuschat: {
      type: "http",
      url: `${baseUrl}/mcp`,
    },
  };
}

/**
 * List of allowed MCP tools for census queries
 */
export const CENSUS_TOOLS = [
  "mcp__censuschat__execute_query",
  "mcp__censuschat__get_information_schema",
  "mcp__censuschat__validate_sql_query",
] as const;
```

2. Create `backend/src/agent/agents/regionAnalyzer.ts` with configuration:

```typescript
/**
 * Region Analyzer Configuration
 * Configuration for analyzing demographic data in a specific region
 * Used for parallel region comparisons
 */
import { z } from "zod";
import { CENSUS_TOOLS } from "../mcpConfig";

/**
 * Schema for region analysis results (used in comparisons)
 */
export const RegionAnalysisResultSchema = z.object({
  region_name: z.string(),
  total_population: z.number(),
  seniors_65_plus: z.number().optional(),
  median_income: z.number().optional(),
  key_metrics: z.record(z.string(), z.unknown()).optional(),
});

export type RegionAnalysisResult = z.infer<typeof RegionAnalysisResultSchema>;

/**
 * Configuration for region analyzer agent
 */
export const regionAnalyzerConfig = {
  description: "Analyzes demographic data for a specific geographic region using Census data",
  systemPrompt: `You are a census data analyst specializing in regional demographics.

When given a region (city, county, or metro area), you will:
1. Query the census database for key demographic metrics
2. Focus on: population, age distribution (especially 65+), income levels, and healthcare access indicators
3. Return structured data suitable for comparison

Use the execute_query tool to run SQL queries against the census database.
Available tables: county_data, block_group_data_expanded

For city/metro area queries, search by county_name patterns (e.g., "Tampa" matches counties in Tampa Bay area).

Always return results in JSON format with:
- region_name: The region analyzed
- total_population: Total population
- seniors_65_plus: Population aged 65+
- median_income: Median household income
- key_metrics: Object with additional relevant metrics`,
  tools: [...CENSUS_TOOLS],
  model: "claude-sonnet-4-20250514",
};
```

3. Create `backend/src/agent/agents/index.ts` barrel export:

```typescript
export * from "./regionAnalyzer";
```
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/agent/agents/regionAnalyzer.ts` compiles
    - `npx tsc --noEmit backend/src/agent/mcpConfig.ts` compiles
  </verify>
  <done>
    - regionAnalyzerConfig exported with proper configuration
    - MCP config centralized in mcpConfig.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comparison query support to agentService</name>
  <files>
    backend/src/agent/agentService.ts
  </files>
  <action>
Extend `backend/src/agent/agentService.ts` to support multi-region comparisons.

Add the following to the existing file (after the existing imports and before the anthropic constant):

```typescript
// Add imports at top
import { regionAnalyzerConfig, RegionAnalysisResultSchema } from "./agents";
import { getMcpConfig, CENSUS_TOOLS } from "./mcpConfig";
import { zodToJsonSchema } from "zod-to-json-schema";
```

Add the comparison schema and functions (add before the AgentService class):

```typescript
// Comparison response schema
export const ComparisonResponseSchema = z.object({
  success: z.boolean(),
  comparison: z.object({
    regions: z.array(z.object({
      region_name: z.string(),
      total_population: z.number(),
      seniors_65_plus: z.number().optional(),
      median_income: z.number().optional(),
      key_metrics: z.record(z.string(), z.unknown()).optional(),
    })),
    summary: z.string(),
    differences: z.array(z.string()).optional(),
  }),
  explanation: z.string(),
});

export type ComparisonResponse = z.infer<typeof ComparisonResponseSchema>;

/**
 * Compare multiple regions
 * Example: "Compare Tampa Bay vs Phoenix for Medicare eligible population"
 */
export async function queryComparison(
  prompt: string,
  options: AgentQueryOptions = {}
): Promise<AgentQueryResult<ComparisonResponse>> {
  const model = options.model || "claude-sonnet-4-20250514";
  const maxTokens = options.maxTokens || 8192;

  // Convert schema to JSON Schema using zodToJsonSchema (NOT z.toJSONSchema which doesn't exist)
  const jsonSchema = zodToJsonSchema(ComparisonResponseSchema, {
    name: "comparison_response",
    $refStrategy: "none",
  });

  const systemPrompt = `You are a census data analyst for CensusChat specializing in regional comparisons.

When comparing regions, analyze demographic data and respond with JSON in this exact format:
{
  "success": true/false,
  "comparison": {
    "regions": [
      {
        "region_name": "Region Name",
        "total_population": number,
        "seniors_65_plus": number (optional),
        "median_income": number (optional),
        "key_metrics": { additional metrics }
      }
    ],
    "summary": "Brief comparison summary",
    "differences": ["Notable difference 1", "Notable difference 2"]
  },
  "explanation": "Detailed explanation of comparison"
}`;

  try {
    const response = await anthropic.messages.create({
      model,
      max_tokens: maxTokens,
      system: systemPrompt,
      messages: [
        {
          role: "user",
          content: `Compare the following regions: ${prompt}`,
        },
      ],
    });

    const textContent = response.content.find((block) => block.type === "text");
    if (!textContent || textContent.type !== "text") {
      return {
        success: false,
        error: "No text content in comparison response",
      };
    }

    let parsed: unknown;
    try {
      parsed = JSON.parse(textContent.text);
    } catch {
      return {
        success: false,
        error: `Failed to parse comparison JSON: ${textContent.text.substring(0, 100)}...`,
      };
    }

    const validated = ComparisonResponseSchema.safeParse(parsed);
    if (!validated.success) {
      return {
        success: false,
        error: `Comparison schema validation failed: ${validated.error.message}`,
      };
    }

    return {
      success: true,
      data: validated.data,
      usage: {
        inputTokens: response.usage.input_tokens,
        outputTokens: response.usage.output_tokens,
      },
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown comparison error",
    };
  }
}

/**
 * Detect if a query is a comparison request
 */
export function isComparisonQuery(prompt: string): boolean {
  const comparisonPatterns = [
    /\bcompare\b/i,
    /\bvs\.?\b/i,
    /\bversus\b/i,
    /\bdifference between\b/i,
    /\bhow does.*compare\b/i,
    /\bwhich.*better\b/i,
  ];
  return comparisonPatterns.some(pattern => pattern.test(prompt));
}
```

Update the existing AgentService class to handle comparisons:

```typescript
/**
 * AgentService class for stateful usage
 */
export class AgentService {
  private model: string;
  private systemPrompt?: string;

  constructor(options?: { model?: string; systemPrompt?: string }) {
    this.model = options?.model || "claude-sonnet-4-20250514";
    this.systemPrompt = options?.systemPrompt;
  }

  async query(prompt: string): Promise<AgentQueryResult<QueryResponse | ComparisonResponse>> {
    // Detect comparison queries and route appropriately
    if (isComparisonQuery(prompt)) {
      return queryComparison(prompt, {
        model: this.model,
      }) as Promise<AgentQueryResult<QueryResponse | ComparisonResponse>>;
    }

    // Standard query
    return queryCensus(prompt, {
      model: this.model,
      systemPrompt: this.systemPrompt,
    });
  }

  async queryWithSchema<T extends z.ZodType>(
    prompt: string,
    schema: T
  ): Promise<AgentQueryResult<z.infer<T>>> {
    return queryWithSchema(prompt, schema, {
      model: this.model,
      systemPrompt: this.systemPrompt,
    });
  }
}
```
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/agent/agentService.ts` compiles
    - isComparisonQuery("Compare Tampa vs Phoenix") returns true
    - isComparisonQuery("Show seniors in Florida") returns false
  </verify>
  <done>
    - queryComparison() uses zodToJsonSchema() (not the non-existent z.toJSONSchema())
    - AgentService.query() auto-detects comparison queries
    - ComparisonResponseSchema defined and exported
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire query routes to use AgentService</name>
  <files>
    backend/src/routes/query.routes.ts
  </files>
  <action>
Update `backend/src/routes/query.routes.ts` to use AgentService alongside existing flow:

1. Add imports at top:
```typescript
import { AgentService, isComparisonQuery } from '../agent/agentService';
```

2. Add feature flag near other flags:
```typescript
// Feature flag for Agent SDK usage (gradual rollout)
const USE_AGENT_SDK = process.env.USE_AGENT_SDK === 'true';
```

3. In the POST '/' handler, add Agent SDK path before existing flow:

Find the `processQuery` async function and add this at the beginning, before Step 0:

```typescript
// Agent SDK path (opt-in via feature flag)
if (USE_AGENT_SDK) {
  console.log('Using Agent SDK for query processing...');

  // Get or create agent service (could be per-request or singleton)
  const agentService = new AgentService();

  const agentResult = await agentService.query(preprocessedQuery);

  if (agentResult.success && agentResult.data) {
    const queryTime = (Date.now() - startTime) / 1000;

    // Handle comparison responses
    if ('comparison' in agentResult.data) {
      return {
        success: true,
        message: `Comparison complete for ${agentResult.data.comparison.regions.length} regions`,
        data: agentResult.data.comparison.regions,
        comparison: agentResult.data.comparison,
        metadata: {
          queryTime,
          totalRecords: agentResult.data.comparison.regions.length,
          dataSource: 'Agent SDK with MCP',
          confidenceLevel: 0.95,
          usedAgentSDK: true,
          analysis: { explanation: agentResult.data.explanation },
        },
      };
    }

    // Handle standard query responses
    return {
      success: true,
      message: `Found ${agentResult.data.metadata.rowCount} records`,
      data: agentResult.data.data,
      metadata: {
        queryTime,
        totalRecords: agentResult.data.metadata.rowCount,
        dataSource: 'Agent SDK with MCP',
        confidenceLevel: 0.95,
        usedAgentSDK: true,
        analysis: {
          explanation: agentResult.data.explanation,
          suggestedRefinements: agentResult.data.suggestedRefinements,
        },
      },
    };
  } else {
    console.warn('Agent SDK query failed, falling back to standard flow:', agentResult.error);
    // Fall through to standard processing below
  }
}
```

Note: This is additive - existing anthropicService + MCP flow remains as fallback.
The feature flag allows gradual rollout and easy rollback.
  </action>
  <verify>
    - `npx tsc --noEmit backend/src/routes/query.routes.ts` compiles
    - With USE_AGENT_SDK=false, existing flow unchanged
    - Imports resolve correctly
  </verify>
  <done>
    - query.routes.ts imports AgentService
    - Feature flag USE_AGENT_SDK controls opt-in
    - Comparison queries return regions array with comparison metadata
    - Fallback to existing flow on Agent SDK failure
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd backend && npx tsc --noEmit` compiles without errors
2. File structure exists:
   - backend/src/agent/mcpConfig.ts
   - backend/src/agent/agents/regionAnalyzer.ts
   - backend/src/agent/agents/index.ts
3. query.routes.ts contains AgentService import
4. isComparisonQuery() correctly detects comparison patterns
5. agentService.ts uses zodToJsonSchema() (not z.toJSONSchema())
</verification>

<success_criteria>
- MCP config centralized and importable
- regionAnalyzerConfig defined with proper structure
- AgentService.query() handles both standard and comparison queries
- query.routes.ts integrates AgentService with feature flag
- Comparison queries detected and routed to queryComparison()
- Uses zodToJsonSchema() correctly throughout
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-sdk-integration/04-02-SUMMARY.md`
</output>
