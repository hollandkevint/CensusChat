---
phase: 04-agent-sdk-integration
plan: 05
type: execute
wave: 2
depends_on: ["04-04"]
files_modified:
  - backend/src/agent/agentService.ts
  - backend/src/agent/agentSdkService.ts
  - backend/src/routes/query.routes.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Conversational context persists - 'Now filter to income > $75K' references prior query"
    - "Session context (lastQuery, lastResult) injected into prompts"
    - "Parallel region comparison uses Promise.all or Agent SDK subagents"
  artifacts:
    - path: "backend/src/agent/agentService.ts"
      provides: "Session context injection in query()"
      contains: "getSession"
    - path: "backend/src/agent/agentSdkService.ts"
      provides: "Parallel comparison with Agent SDK"
      contains: "Promise.all"
  key_links:
    - from: "agentService.ts query()"
      to: "sessionManager.getSession()"
      via: "context retrieval"
      pattern: 'getSession.*lastQuery|lastResult'
    - from: "agentSdkService.ts"
      to: "parallel execution"
      via: "Promise.all or subagents"
      pattern: 'Promise\.all|subagent'
---

<objective>
Wire session context injection so follow-up queries reference prior context, and implement parallel region comparison for "Compare Tampa Bay vs Phoenix" queries.

Purpose: Close Gaps 2 and 3 from VERIFICATION.md:
- Gap 2: Session manager stores sessions but never retrieves/injects into queries
- Gap 3: Comparison queries run sequentially, not parallel

Output: Conversational context works ("Now filter to income > $75K" references prior query) and comparison queries execute in parallel.
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-agent-sdk-integration/04-RESEARCH.md
@.planning/phases/04-agent-sdk-integration/04-VERIFICATION.md
@.planning/phases/04-agent-sdk-integration/04-04-PLAN.md

# Files to modify
@backend/src/agent/agentService.ts
@backend/src/agent/sessionManager.ts
@backend/src/agent/agentSdkService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inject session context into agentService queries</name>
  <files>
    backend/src/agent/agentService.ts
  </files>
  <action>
Modify `AgentService.query()` to retrieve and inject session context:

1. At the start of `query()` method, retrieve previous session:
   ```typescript
   async query(prompt: string): Promise<AgentQueryResult<QueryResponse | ComparisonResponse>> {
     // Retrieve session context for conversational follow-up
     const sessionId = this.sessionManager.getSessionIdForUser(this.userId);
     let contextPrompt = prompt;

     if (sessionId) {
       const session = this.sessionManager.getSession(sessionId);
       if (session?.lastQuery && session?.lastResult) {
         // Inject prior context for follow-up queries
         contextPrompt = this.buildContextualPrompt(prompt, session);
       }
     }

     // Use contextPrompt instead of prompt in subsequent calls...
   }
   ```

2. Add helper method `buildContextualPrompt()`:
   ```typescript
   private buildContextualPrompt(prompt: string, session: SessionContext): string {
     const priorContext = `
Previous query: "${session.lastQuery}"
Previous result summary: ${this.summarizeResult(session.lastResult)}

Current query: "${prompt}"

If the current query references "it", "that", "these", or uses refinement language like "now filter", "also show", "but only", interpret in context of the previous query.`;

     return priorContext;
   }

   private summarizeResult(result: unknown): string {
     if (!result) return "No prior result";
     const r = result as Record<string, unknown>;
     if (r.data && Array.isArray(r.data)) {
       return `${r.data.length} rows of data`;
     }
     if (r.comparison && typeof r.comparison === 'object') {
       const comp = r.comparison as { regions?: unknown[] };
       return `Comparison of ${comp.regions?.length || 0} regions`;
     }
     return "Prior query completed";
   }
   ```

3. Update both the standard query path and comparison query path to use `contextPrompt`:
   - In `queryCensus()` call: pass contextPrompt
   - In `queryComparison()` call: pass contextPrompt

4. Import SessionContext type from sessionManager.ts if not already imported.

Note: Keep the existing storeSession() calls - they continue to store results for the next query.
  </action>
  <verify>
    - `grep -n "getSession" backend/src/agent/agentService.ts` shows session retrieval
    - `grep -n "buildContextualPrompt" backend/src/agent/agentService.ts` shows helper method
    - `grep -n "contextPrompt" backend/src/agent/agentService.ts` shows usage
    - TypeScript compiles: `cd backend && npx tsc --noEmit src/agent/agentService.ts`
  </verify>
  <done>
    AgentService.query() retrieves session context and injects prior query/result into prompts for conversational follow-up. Follow-up queries like "Now filter to income > $75K" reference prior context.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement parallel region comparison</name>
  <files>
    backend/src/agent/agentSdkService.ts
    backend/src/agent/agentService.ts
  </files>
  <action>
1. In `agentSdkService.ts`, add parallel comparison function using Agent SDK subagents OR Promise.all pattern:

   **Option A - Agent SDK Subagents (preferred if SDK supports):**
   ```typescript
   export async function queryComparisonParallel(
     prompt: string,
     regions: string[]
   ): Promise<AgentSdkResult> {
     // Use Agent SDK with Task tool for parallel subagent execution
     const subagentPrompt = `Use the region-analyzer subagent to analyze each of these regions in parallel: ${regions.join(", ")}. Compare the results.`;

     for await (const message of query({
       prompt: subagentPrompt,
       options: {
         mcpServers: { /* ... */ },
         allowedTools: [...CENSUS_TOOLS, "Task"],
         agents: {
           "region-analyzer": regionAnalyzerConfig
         }
       }
     })) {
       // Handle messages from parent and subagents
     }
   }
   ```

   **Option B - Promise.all fallback (if SDK subagents unavailable):**
   ```typescript
   export async function queryComparisonParallel(
     prompt: string,
     regions: string[]
   ): Promise<ComparisonResponse> {
     // Extract regions from prompt
     const extractedRegions = extractRegions(prompt);
     if (extractedRegions.length < 2) {
       // Fall back to single query
       return queryComparison(prompt);
     }

     // Run region queries in parallel
     const regionPromises = extractedRegions.map(region =>
       queryWithAgentSdk(`Analyze demographic data for ${region}`)
     );

     const results = await Promise.all(regionPromises);

     // Combine results into comparison format
     return combineRegionResults(results);
   }

   function extractRegions(prompt: string): string[] {
     // Match patterns like "Tampa Bay vs Phoenix" or "compare A, B, and C"
     const vsMatch = prompt.match(/(.+?)\s+(?:vs\.?|versus)\s+(.+?)(?:\s+for|$)/i);
     if (vsMatch) return [vsMatch[1].trim(), vsMatch[2].trim()];

     const compareMatch = prompt.match(/compare\s+(.+?)\s+(?:and|,)\s+(.+?)(?:\s+for|$)/i);
     if (compareMatch) return [compareMatch[1].trim(), compareMatch[2].trim()];

     return [];
   }
   ```

2. In `agentService.ts`, update `queryComparison()` to use parallel execution:
   - If USE_AGENT_SDK=true, call `queryComparisonParallel()`
   - Otherwise, fall back to existing sequential comparison

3. Add Promise.all pattern to existing agentService.ts for non-SDK parallel:
   ```typescript
   // In queryComparison or a new parallelQueryComparison
   const regions = extractRegionsFromPrompt(prompt);
   if (regions.length >= 2) {
     const promises = regions.map(region =>
       queryCensus(`Demographics for ${region}`, options)
     );
     const results = await Promise.all(promises);
     return combineIntoComparison(results, regions);
   }
   ```

4. Helper function `combineIntoComparison()`:
   ```typescript
   function combineIntoComparison(
     results: AgentQueryResult<QueryResponse>[],
     regionNames: string[]
   ): ComparisonResponse {
     return {
       success: results.every(r => r.success),
       comparison: {
         regions: results.map((r, i) => ({
           region_name: regionNames[i],
           total_population: extractPopulation(r.data),
           // ... other fields
         })),
         summary: `Comparison of ${regionNames.join(" vs ")}`,
         differences: []
       },
       explanation: `Parallel comparison of ${regionNames.length} regions`
     };
   }
   ```
  </action>
  <verify>
    - `grep -n "Promise.all" backend/src/agent/agentSdkService.ts` shows parallel execution
    - `grep -n "extractRegions" backend/src/agent/agentSdkService.ts` shows region parsing
    - TypeScript compiles: `cd backend && npx tsc --noEmit src/agent/agentSdkService.ts`
  </verify>
  <done>
    Comparison queries use parallel execution via Promise.all or Agent SDK subagents. "Compare Tampa Bay vs Phoenix" runs both region queries simultaneously.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for context injection and parallel comparison</name>
  <files>
    backend/src/__tests__/agent/contextInjection.test.ts
  </files>
  <action>
Create `backend/src/__tests__/agent/contextInjection.test.ts` with:

1. Test session context injection:
   ```typescript
   describe("Session Context Injection", () => {
     it("should inject prior query context for follow-up queries", async () => {
       const service = new AgentService({ userId: "test-user" });

       // Mock first query and store session
       // ...

       // Second query should reference prior context
       // Verify buildContextualPrompt was called with session data
     });

     it("should not inject context if no prior session", async () => {
       // New user, no session - should use original prompt
     });
   });
   ```

2. Test parallel comparison:
   ```typescript
   describe("Parallel Comparison", () => {
     it("should extract regions from 'A vs B' pattern", () => {
       const regions = extractRegions("Tampa Bay vs Phoenix for seniors");
       expect(regions).toEqual(["Tampa Bay", "Phoenix"]);
     });

     it("should extract regions from 'compare A and B' pattern", () => {
       const regions = extractRegions("compare Dallas and Houston");
       expect(regions).toEqual(["Dallas", "Houston"]);
     });

     it("should run parallel queries for multi-region comparison", async () => {
       // Mock Promise.all behavior
       // Verify both regions queried simultaneously
     });
   });
   ```

3. Test context flow end-to-end (with mocks):
   ```typescript
   describe("Conversational Context Flow", () => {
     it("should handle 'now filter to income > $75K' after prior query", async () => {
       // Setup: Prior query for "seniors in Tampa Bay"
       // Execute: "now filter to income > $75K"
       // Verify: Context prompt includes prior query reference
     });
   });
   ```
  </action>
  <verify>
    - `cd backend && npm test -- --testPathPattern=contextInjection --passWithNoTests`
    - Tests pass with mocks
  </verify>
  <done>
    Tests verify context injection, region extraction, and parallel comparison behavior. All tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Context injection verification:
   ```bash
   grep -A5 "getSession" backend/src/agent/agentService.ts | head -20
   ```
   Should show session retrieval and context building

2. Parallel execution verification:
   ```bash
   grep -B2 -A5 "Promise.all" backend/src/agent/agentSdkService.ts
   ```
   Should show parallel region queries

3. Region extraction verification:
   ```bash
   grep -A10 "extractRegions" backend/src/agent/agentSdkService.ts
   ```
   Should show pattern matching for "vs", "compare" etc.

4. Tests pass:
   ```bash
   cd backend && npm test -- --testPathPattern="contextInjection|agentSdkService"
   ```

5. TypeScript compilation:
   ```bash
   cd backend && npx tsc --noEmit
   ```
</verification>

<success_criteria>
- AgentService.query() retrieves session context via getSession()
- Prior query/result injected into follow-up query prompts
- buildContextualPrompt() helper method exists
- extractRegions() parses "A vs B" and "compare A and B" patterns
- Promise.all used for parallel region queries
- Tests pass verifying context injection and parallel behavior
- "Now filter to income > $75K" correctly references prior query context
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-sdk-integration/04-05-SUMMARY.md`
</output>
