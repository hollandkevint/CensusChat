---
phase: 01-duckdb-upgrade
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/scripts/migrate-encrypted.ts
  - backend/src/utils/duckdbPool.ts
  - backend/src/services/dataRefreshService.ts
  - backend/.env.example
autonomous: true
user_setup:
  - service: duckdb-encryption
    why: "Encryption key for census.duckdb"
    env_vars:
      - name: DUCKDB_ENCRYPTION_KEY
        source: "Generate 32-character random string (e.g., openssl rand -hex 16)"
    dashboard_config: []

must_haves:
  truths:
    - "Database opens with encryption key from environment variable"
    - "Migration script copies all data to encrypted database"
    - "Row counts match between source and encrypted destination"
    - "Data refresh uses MERGE INTO instead of delete/insert"
  artifacts:
    - path: "backend/scripts/migrate-encrypted.ts"
      provides: "One-time migration script"
      exports: ["migrateToEncrypted"]
      min_lines: 80
    - path: "backend/src/utils/duckdbPool.ts"
      provides: "Pool with encryption support"
      contains: "DUCKDB_ENCRYPTION_KEY"
    - path: "backend/.env.example"
      provides: "Example config with encryption key"
      contains: "DUCKDB_ENCRYPTION_KEY"
  key_links:
    - from: "backend/scripts/migrate-encrypted.ts"
      to: "backend/data/census.duckdb"
      via: "ATTACH with ENCRYPTION_KEY"
      pattern: "ENCRYPTION_KEY.*ENCRYPTION_CIPHER"
    - from: "backend/src/utils/duckdbPool.ts"
      to: "process.env.DUCKDB_ENCRYPTION_KEY"
      via: "environment variable"
      pattern: "process\\.env\\.DUCKDB_ENCRYPTION_KEY"
---

<objective>
Enable AES-256-GCM encryption for census.duckdb and implement MERGE statement for data refresh.

Purpose: Census data contains demographic information that should be encrypted at rest. MERGE replaces the inefficient delete/insert pattern in data refresh workflows, providing atomicity and better performance.

Output: Migration script to encrypt existing database, pool configured for encrypted connections, MERGE-based data refresh.
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-duckdb-upgrade/01-RESEARCH.md
@.planning/phases/01-duckdb-upgrade/01-01-SUMMARY.md

# Files to modify
@backend/src/utils/duckdbPool.ts
@backend/src/services/dataRefreshService.ts
@backend/.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database encryption migration script</name>
  <files>backend/scripts/migrate-encrypted.ts</files>
  <action>
    Create a migration script following the pattern from RESEARCH.md "Database Migration Script":

    ```typescript
    import { DuckDBInstance } from '@duckdb/node-api';
    import * as fs from 'fs';
    import * as path from 'path';

    async function migrateToEncrypted(
      sourcePath: string,
      destPath: string,
      encryptionKey: string
    ): Promise<void> {
      // 1. Create in-memory instance for migration
      const instance = await DuckDBInstance.create(':memory:');
      const conn = await instance.connect();

      // 2. Load httpfs for hardware-accelerated encryption
      await conn.run('INSTALL httpfs; LOAD httpfs;');

      // 3. Attach source (unencrypted)
      await conn.run(`ATTACH '${sourcePath}' AS source`);

      // 4. Attach destination with encryption
      await conn.run(`
        ATTACH '${destPath}' AS dest (
          ENCRYPTION_KEY '${encryptionKey}',
          ENCRYPTION_CIPHER 'GCM'
        )
      `);

      // 5. Copy all data
      console.log('Copying data to encrypted database...');
      await conn.run('COPY FROM DATABASE source TO dest');

      // 6. Verify row counts for each table
      // Query source and dest counts, compare, throw if mismatch
      // See RESEARCH.md for verification pattern

      // 7. Cleanup
      conn.disconnectSync();
      instance.closeSync();

      console.log('Migration complete. Verify and swap databases manually.');
    }

    // CLI entrypoint
    async function main() {
      const sourcePath = process.env.DUCKDB_SOURCE_PATH || './data/census.duckdb';
      const destPath = process.env.DUCKDB_DEST_PATH || './data/census-encrypted.duckdb';
      const encryptionKey = process.env.DUCKDB_ENCRYPTION_KEY;

      if (!encryptionKey) {
        console.error('ERROR: DUCKDB_ENCRYPTION_KEY environment variable required');
        console.error('Generate with: openssl rand -hex 16');
        process.exit(1);
      }

      if (!fs.existsSync(sourcePath)) {
        console.error(`ERROR: Source database not found: ${sourcePath}`);
        process.exit(1);
      }

      await migrateToEncrypted(sourcePath, destPath, encryptionKey);
    }

    main().catch(console.error);
    ```

    Add npm script to package.json:
    ```json
    "migrate-encrypted": "ts-node scripts/migrate-encrypted.ts"
    ```
  </action>
  <verify>
    ```bash
    cd backend && npm run typecheck
    ```
    Script should compile without errors.
  </verify>
  <done>Migration script exists at backend/scripts/migrate-encrypted.ts with row count verification</done>
</task>

<task type="auto">
  <name>Task 2: Add encryption support to DuckDBPool</name>
  <files>backend/src/utils/duckdbPool.ts, backend/.env.example</files>
  <action>
    1. **Update DuckDBPoolConfig interface** to include encryption:
       ```typescript
       export interface DuckDBPoolConfig {
         // ... existing fields
         encryptionKey?: string;
       }
       ```

    2. **Update constructor** to read encryption key from environment:
       ```typescript
       this.config = {
         // ... existing defaults
         encryptionKey: config.encryptionKey || process.env.DUCKDB_ENCRYPTION_KEY || '',
         ...config
       };
       ```

    3. **Update initialize()** to handle encrypted databases:
       - If encryptionKey is set, the database file must already be encrypted
       - The key is passed via instance configuration, not ATTACH
       - For encrypted persistent databases, use DuckDBInstance.create() with encryption config

    4. **Add DUCKDB_ENCRYPTION_KEY to .env.example**:
       ```
       # DuckDB Encryption (optional - leave empty for unencrypted database)
       # Generate with: openssl rand -hex 16
       DUCKDB_ENCRYPTION_KEY=
       ```

    Note: The pool should work with or without encryption. If DUCKDB_ENCRYPTION_KEY is not set, connect to unencrypted database as before.
  </action>
  <verify>
    ```bash
    cd backend && npm run typecheck
    ```
    Pool should compile with new encryptionKey field.
  </verify>
  <done>DuckDBPool supports encryptionKey config, reads from DUCKDB_ENCRYPTION_KEY env var</done>
</task>

<task type="auto">
  <name>Task 3: Implement MERGE statement for data refresh</name>
  <files>backend/src/services/dataRefreshService.ts</files>
  <action>
    Add MERGE-based refresh method to DataRefreshService. This doesn't replace existing methods immediately but provides the new pattern.

    1. **Add new method** for MERGE-based county data refresh:
       ```typescript
       async refreshCountyDataWithMerge(
         newData: Array<{ state_fips: string; county_fips: string; population: number; median_income: number }>
       ): Promise<{ updated: number; inserted: number }> {
         const pool = getDuckDBPool();
         const conn = await pool.acquire();

         try {
           // Create staging table from new data
           await conn.run(`
             CREATE OR REPLACE TEMP TABLE staging_county AS
             SELECT * FROM (VALUES ${newData.map(d =>
               `('${d.state_fips}', '${d.county_fips}', ${d.population}, ${d.median_income})`
             ).join(',')}) AS t(state_fips, county_fips, population, median_income)
           `);

           // MERGE with RETURNING to count actions
           const reader = await conn.runAndReadAll(`
             MERGE INTO county_data AS target
             USING staging_county AS source
             ON target.state_fips = source.state_fips
                AND target.county_fips = source.county_fips
             WHEN MATCHED THEN UPDATE SET
               population = source.population,
               median_income = source.median_income
             WHEN NOT MATCHED THEN INSERT BY NAME
             RETURNING merge_action
           `);

           const actions = reader.getRowObjects();
           return {
             updated: actions.filter((a: any) => a.merge_action === 'UPDATE').length,
             inserted: actions.filter((a: any) => a.merge_action === 'INSERT').length
           };
         } finally {
           pool.release(conn);
         }
       }
       ```

    2. **Add import** for getDuckDBPool at top of file

    3. **Document** that this method requires DuckDB 1.4+ (already satisfied by Plan 01)
  </action>
  <verify>
    ```bash
    cd backend && npm run typecheck
    ```
    DataRefreshService should compile with new MERGE method.
  </verify>
  <done>DataRefreshService has refreshCountyDataWithMerge() using MERGE INTO with RETURNING</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript compiles cleanly:**
   ```bash
   cd backend && npm run typecheck
   ```

2. **Migration script exists and is valid:**
   ```bash
   ls backend/scripts/migrate-encrypted.ts
   ```

3. **Environment example updated:**
   ```bash
   grep DUCKDB_ENCRYPTION_KEY backend/.env.example
   ```

4. **Pool has encryption support:**
   ```bash
   grep encryptionKey backend/src/utils/duckdbPool.ts
   ```

5. **MERGE method exists:**
   ```bash
   grep refreshCountyDataWithMerge backend/src/services/dataRefreshService.ts
   ```
</verification>

<success_criteria>
- Migration script compiles and includes row count verification
- DuckDBPool accepts encryptionKey config and reads DUCKDB_ENCRYPTION_KEY env var
- .env.example documents DUCKDB_ENCRYPTION_KEY
- DataRefreshService has refreshCountyDataWithMerge() using MERGE INTO
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-duckdb-upgrade/01-02-SUMMARY.md`
</output>
