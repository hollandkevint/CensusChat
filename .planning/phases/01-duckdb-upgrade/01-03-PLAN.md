---
phase: 01-duckdb-upgrade
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/src/utils/duckdbProfiler.ts
  - backend/src/routes/metrics.routes.ts
  - backend/src/routes/index.ts
  - backend/src/__tests__/utils/duckdbProfiler.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Queries can be executed with profiling enabled"
    - "Profile data includes CPU time and operator timing"
    - "Metrics endpoint returns query performance data"
    - "Profiling can be disabled for production queries"
  artifacts:
    - path: "backend/src/utils/duckdbProfiler.ts"
      provides: "Query profiling utility"
      exports: ["queryWithProfiling", "QueryProfile"]
      min_lines: 60
    - path: "backend/src/routes/metrics.routes.ts"
      provides: "Metrics API endpoint"
      exports: ["metricsRouter"]
    - path: "backend/src/__tests__/utils/duckdbProfiler.test.ts"
      provides: "Profiler unit tests"
      min_lines: 40
  key_links:
    - from: "backend/src/utils/duckdbProfiler.ts"
      to: "DuckDBConnection"
      via: "profiling settings"
      pattern: "SET enable_profiling"
    - from: "backend/src/routes/metrics.routes.ts"
      to: "backend/src/utils/duckdbProfiler.ts"
      via: "import"
      pattern: "from.*duckdbProfiler"
---

<objective>
Add query profiler integration and metrics endpoint for performance monitoring.

Purpose: Production systems need visibility into query performance. DuckDB 1.4's profiler provides CPU time, operator timing, and cardinality metrics that help identify slow queries and optimization opportunities.

Output: Profiler utility that wraps queries, metrics endpoint exposing performance data, and tests.
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-duckdb-upgrade/01-RESEARCH.md
@.planning/phases/01-duckdb-upgrade/01-01-SUMMARY.md

# Existing routes pattern
@backend/src/routes/index.ts
@backend/src/utils/duckdbPool.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DuckDB profiler utility</name>
  <files>backend/src/utils/duckdbProfiler.ts</files>
  <action>
    Create a profiler utility following the pattern from RESEARCH.md "Profiler Integration":

    ```typescript
    import { DuckDBConnection } from '@duckdb/node-api';
    import { getDuckDBPool } from './duckdbPool';
    import * as fs from 'fs/promises';
    import * as path from 'path';
    import * as os from 'os';

    export interface QueryProfile {
      query: string;
      executionTimeMs: number;
      cpuTimeUs?: number;
      operatorTimings?: Array<{
        operator: string;
        timeUs: number;
        cardinality: number;
      }>;
      rowsReturned: number;
      timestamp: Date;
    }

    export interface ProfiledQueryResult<T> {
      result: T[];
      profile: QueryProfile;
    }

    // Store recent profiles in memory (last N queries)
    const recentProfiles: QueryProfile[] = [];
    const MAX_STORED_PROFILES = 100;

    export async function queryWithProfiling<T = any>(
      sql: string,
      options: { storeProfile?: boolean } = { storeProfile: true }
    ): Promise<ProfiledQueryResult<T>> {
      const pool = getDuckDBPool();
      const conn = await pool.acquire();
      const startTime = Date.now();

      try {
        // Generate unique profile output path
        const profilePath = path.join(os.tmpdir(), `duckdb_profile_${Date.now()}.json`);

        // Enable JSON profiling
        await conn.run(`SET profiling_output = '${profilePath}'`);
        await conn.run(`SET enable_profiling = 'json'`);
        await conn.run(`SET custom_profiling_settings = '{"CPU_TIME": "true", "OPERATOR_TIMING": "true", "OPERATOR_CARDINALITY": "true"}'`);

        // Execute query
        const reader = await conn.runAndReadAll(sql);
        const result = reader.getRowObjects() as T[];

        // Read profile data
        let profileData: any = {};
        try {
          const profileContent = await fs.readFile(profilePath, 'utf-8');
          profileData = JSON.parse(profileContent);
          await fs.unlink(profilePath); // Cleanup
        } catch (e) {
          console.warn('Could not read profile data:', e);
        }

        // Disable profiling
        await conn.run(`SET enable_profiling = 'no_output'`);

        const profile: QueryProfile = {
          query: sql.substring(0, 500), // Truncate long queries
          executionTimeMs: Date.now() - startTime,
          cpuTimeUs: profileData.cpu_time,
          operatorTimings: profileData.children?.map((op: any) => ({
            operator: op.name,
            timeUs: op.timing,
            cardinality: op.cardinality
          })),
          rowsReturned: result.length,
          timestamp: new Date()
        };

        if (options.storeProfile) {
          storeProfile(profile);
        }

        return { result, profile };
      } finally {
        pool.release(conn);
      }
    }

    function storeProfile(profile: QueryProfile): void {
      recentProfiles.unshift(profile);
      if (recentProfiles.length > MAX_STORED_PROFILES) {
        recentProfiles.pop();
      }
    }

    export function getRecentProfiles(limit: number = 10): QueryProfile[] {
      return recentProfiles.slice(0, limit);
    }

    export function clearProfiles(): void {
      recentProfiles.length = 0;
    }

    export function getProfileStats(): {
      totalQueries: number;
      avgExecutionTimeMs: number;
      slowestQueryMs: number;
      totalRowsReturned: number;
    } {
      if (recentProfiles.length === 0) {
        return {
          totalQueries: 0,
          avgExecutionTimeMs: 0,
          slowestQueryMs: 0,
          totalRowsReturned: 0
        };
      }

      const totalTime = recentProfiles.reduce((sum, p) => sum + p.executionTimeMs, 0);
      const slowest = Math.max(...recentProfiles.map(p => p.executionTimeMs));
      const totalRows = recentProfiles.reduce((sum, p) => sum + p.rowsReturned, 0);

      return {
        totalQueries: recentProfiles.length,
        avgExecutionTimeMs: Math.round(totalTime / recentProfiles.length),
        slowestQueryMs: slowest,
        totalRowsReturned: totalRows
      };
    }
    ```
  </action>
  <verify>
    ```bash
    cd backend && npm run typecheck
    ```
    Profiler utility should compile.
  </verify>
  <done>duckdbProfiler.ts exports queryWithProfiling(), getRecentProfiles(), getProfileStats()</done>
</task>

<task type="auto">
  <name>Task 2: Create metrics API endpoint</name>
  <files>backend/src/routes/metrics.routes.ts, backend/src/routes/index.ts</files>
  <action>
    1. **Create metrics route file:**
       ```typescript
       import { Router, Request, Response } from 'express';
       import { getRecentProfiles, getProfileStats, clearProfiles } from '../utils/duckdbProfiler';
       import { getDuckDBPool } from '../utils/duckdbPool';

       export const metricsRouter = Router();

       // GET /api/v1/metrics/queries - Recent query profiles
       metricsRouter.get('/queries', (req: Request, res: Response) => {
         const limit = parseInt(req.query.limit as string) || 10;
         const profiles = getRecentProfiles(limit);
         res.json({
           success: true,
           data: profiles,
           count: profiles.length
         });
       });

       // GET /api/v1/metrics/stats - Aggregate query statistics
       metricsRouter.get('/stats', (req: Request, res: Response) => {
         const stats = getProfileStats();
         const poolStats = getDuckDBPool().getStats();
         res.json({
           success: true,
           data: {
             queryPerformance: stats,
             connectionPool: poolStats
           }
         });
       });

       // DELETE /api/v1/metrics/queries - Clear stored profiles
       metricsRouter.delete('/queries', (req: Request, res: Response) => {
         clearProfiles();
         res.json({
           success: true,
           message: 'Query profiles cleared'
         });
       });
       ```

    2. **Register route in index.ts:**
       Add import:
       ```typescript
       import { metricsRouter } from './metrics.routes';
       ```

       Add route registration after existing routes:
       ```typescript
       router.use('/metrics', metricsRouter);
       ```
  </action>
  <verify>
    ```bash
    cd backend && npm run typecheck
    ```
    Routes should compile.
  </verify>
  <done>GET /api/v1/metrics/queries and /api/v1/metrics/stats endpoints exist</done>
</task>

<task type="auto">
  <name>Task 3: Add profiler unit tests</name>
  <files>backend/src/__tests__/utils/duckdbProfiler.test.ts</files>
  <action>
    Create tests for the profiler utility:

    ```typescript
    import {
      queryWithProfiling,
      getRecentProfiles,
      getProfileStats,
      clearProfiles
    } from '../../utils/duckdbProfiler';
    import { getDuckDBPool } from '../../utils/duckdbPool';

    // Mock the pool
    jest.mock('../../utils/duckdbPool', () => ({
      getDuckDBPool: jest.fn().mockReturnValue({
        acquire: jest.fn().mockResolvedValue({
          run: jest.fn().mockResolvedValue(undefined),
          runAndReadAll: jest.fn().mockResolvedValue({
            getRowObjects: jest.fn().mockReturnValue([
              { id: 1, name: 'Test' },
              { id: 2, name: 'Test2' }
            ])
          })
        }),
        release: jest.fn()
      })
    }));

    // Mock fs for profile file reading
    jest.mock('fs/promises', () => ({
      readFile: jest.fn().mockResolvedValue(JSON.stringify({
        cpu_time: 1500,
        children: [
          { name: 'SEQ_SCAN', timing: 1000, cardinality: 100 },
          { name: 'PROJECTION', timing: 500, cardinality: 100 }
        ]
      })),
      unlink: jest.fn().mockResolvedValue(undefined)
    }));

    describe('DuckDB Profiler', () => {
      beforeEach(() => {
        clearProfiles();
      });

      describe('queryWithProfiling', () => {
        it('should execute query and return profile data', async () => {
          const { result, profile } = await queryWithProfiling('SELECT * FROM test');

          expect(result).toHaveLength(2);
          expect(profile.query).toContain('SELECT');
          expect(profile.executionTimeMs).toBeGreaterThanOrEqual(0);
          expect(profile.rowsReturned).toBe(2);
          expect(profile.timestamp).toBeInstanceOf(Date);
        });

        it('should store profile by default', async () => {
          await queryWithProfiling('SELECT 1');
          const profiles = getRecentProfiles();

          expect(profiles).toHaveLength(1);
        });

        it('should not store profile when disabled', async () => {
          await queryWithProfiling('SELECT 1', { storeProfile: false });
          const profiles = getRecentProfiles();

          expect(profiles).toHaveLength(0);
        });
      });

      describe('getProfileStats', () => {
        it('should return zero stats when no profiles', () => {
          const stats = getProfileStats();

          expect(stats.totalQueries).toBe(0);
          expect(stats.avgExecutionTimeMs).toBe(0);
        });

        it('should calculate aggregate stats', async () => {
          await queryWithProfiling('SELECT 1');
          await queryWithProfiling('SELECT 2');

          const stats = getProfileStats();

          expect(stats.totalQueries).toBe(2);
          expect(stats.avgExecutionTimeMs).toBeGreaterThanOrEqual(0);
        });
      });

      describe('clearProfiles', () => {
        it('should clear all stored profiles', async () => {
          await queryWithProfiling('SELECT 1');
          await queryWithProfiling('SELECT 2');

          clearProfiles();

          expect(getRecentProfiles()).toHaveLength(0);
        });
      });
    });
    ```
  </action>
  <verify>
    ```bash
    cd backend && npm test -- --testPathPattern="duckdbProfiler.test.ts" --verbose
    ```
    All profiler tests should pass.
  </verify>
  <done>Profiler tests pass covering queryWithProfiling, getRecentProfiles, getProfileStats, clearProfiles</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript compiles cleanly:**
   ```bash
   cd backend && npm run typecheck
   ```

2. **Profiler tests pass:**
   ```bash
   cd backend && npm test -- --testPathPattern="duckdbProfiler"
   ```

3. **All backend tests still pass:**
   ```bash
   cd backend && npm test
   ```

4. **Routes registered:**
   ```bash
   grep -E "metricsRouter|/metrics" backend/src/routes/index.ts
   ```
</verification>

<success_criteria>
- duckdbProfiler.ts exports queryWithProfiling with profile storage
- Metrics endpoint returns recent profiles and aggregate stats
- Pool stats included in metrics response
- Profiler tests pass
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-duckdb-upgrade/01-03-SUMMARY.md`
</output>
