---
phase: 02-mcp-transport
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/src/mcp/mcpClient.ts
  - backend/src/__tests__/mcp/mcpIntegration.test.ts
autonomous: false

must_haves:
  truths:
    - "mcpClient.ts uses HTTP fetch instead of in-process imports"
    - "Client tracks session ID across multiple requests"
    - "Integration test proves end-to-end MCP flow works"
    - "External MCP clients (curl, Postman) can execute queries"
  artifacts:
    - path: "backend/src/mcp/mcpClient.ts"
      provides: "HTTP-based MCP client with session management"
      exports: ["MCPHttpClient", "getMcpClient"]
    - path: "backend/src/__tests__/mcp/mcpIntegration.test.ts"
      provides: "Integration tests for HTTP MCP flow"
      min_lines: 50
  key_links:
    - from: "backend/src/mcp/mcpClient.ts"
      to: "/mcp endpoint"
      via: "HTTP fetch with Mcp-Session-Id header"
      pattern: "fetch.*\\/mcp"
    - from: "backend/src/mcp/mcpClient.ts"
      to: "backend/src/mcp/mcpSessionManager.ts"
      via: "Session ID from initialize response"
      pattern: "Mcp-Session-Id"
---

<objective>
Refactor mcpClient.ts to use HTTP transport and verify end-to-end MCP communication works.

Purpose: Complete the migration by making internal calls use HTTP protocol, proving external connectivity.
Output: HTTP-based MCP client with session tracking and integration tests confirming external access.
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-mcp-transport-migration/02-RESEARCH.md
@.planning/phases/02-mcp-transport-migration/02-01-SUMMARY.md

@backend/src/mcp/mcpClient.ts
@backend/src/mcp/mcpRoutes.ts
@backend/src/mcp/mcpSessionManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor mcpClient.ts to HTTP transport</name>
  <files>
    backend/src/mcp/mcpClient.ts
  </files>
  <action>
Replace in-process direct imports with HTTP fetch calls to /mcp endpoint.

1. Remove imports for:
   - `Client` from SDK (not needed for HTTP client)
   - `StdioClientTransport`
   - Direct imports of `../validation/sqlValidator` and `../utils/duckdbPool`

2. Create `MCPHttpClient` class:
```typescript
export class MCPHttpClient {
  private sessionId: string | null = null;
  private baseUrl: string;

  constructor(baseUrl: string = 'http://localhost:3001') {
    this.baseUrl = baseUrl;
  }

  async initialize(): Promise<void> {
    const response = await fetch(`${this.baseUrl}/mcp`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json, text/event-stream',
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'initialize',
        params: {
          protocolVersion: '2025-03-26',
          clientInfo: { name: 'censuschat-backend', version: '1.0.0' },
          capabilities: {},
        },
      }),
    });

    if (!response.ok) {
      throw new Error(`Initialize failed: ${response.status}`);
    }

    this.sessionId = response.headers.get('Mcp-Session-Id');
    if (!this.sessionId) {
      throw new Error('No session ID in response');
    }
  }

  async callTool(name: string, args: Record<string, unknown> = {}): Promise<any> {
    if (!this.sessionId) {
      await this.initialize();
    }

    const response = await fetch(`${this.baseUrl}/mcp`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json, text/event-stream',
        'Mcp-Session-Id': this.sessionId!,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: Date.now(),
        method: 'tools/call',
        params: { name, arguments: args },
      }),
    });

    if (!response.ok) {
      throw new Error(`Tool call failed: ${response.status}`);
    }

    const result = await response.json();
    if (result.error) {
      throw new Error(result.error.message);
    }

    return result.result;
  }

  async disconnect(): Promise<void> {
    if (!this.sessionId) return;

    await fetch(`${this.baseUrl}/mcp`, {
      method: 'DELETE',
      headers: { 'Mcp-Session-Id': this.sessionId },
    });

    this.sessionId = null;
  }

  getStatus(): { isConnected: boolean; sessionId: string | null } {
    return { isConnected: !!this.sessionId, sessionId: this.sessionId };
  }
}
```

3. Implement convenience methods that match existing interface:
   - `getInformationSchema()` -> calls `callTool('get_information_schema')`
   - `validateSQLQuery(query)` -> calls `callTool('validate_sql_query', { query })`
   - `executeQuery(query)` -> calls `callTool('execute_query', { query })`

4. Keep `MCPToolCallResult` interface for backwards compatibility:
```typescript
export interface MCPToolCallResult {
  success: boolean;
  result?: any;
  error?: string;
  validationErrors?: any[];
}
```

5. Transform tool results to match existing interface:
   - Parse JSON-RPC response content
   - Map to MCPToolCallResult shape

6. Update singleton:
```typescript
let mcpClientInstance: MCPHttpClient | null = null;

export function getMcpClient(): MCPHttpClient {
  if (!mcpClientInstance) {
    const baseUrl = process.env.MCP_SERVER_URL || 'http://localhost:3001';
    mcpClientInstance = new MCPHttpClient(baseUrl);
  }
  return mcpClientInstance;
}

export async function closeMcpClient(): Promise<void> {
  if (mcpClientInstance) {
    await mcpClientInstance.disconnect();
    mcpClientInstance = null;
  }
}
```

7. Add environment variable support:
   - `MCP_SERVER_URL` - base URL for MCP server (default: http://localhost:3001)
  </action>
  <verify>
    cd backend && npm run typecheck
    # Check no direct validator/duckdb imports remain
    grep -E "import.*sqlValidator|import.*duckdbPool" backend/src/mcp/mcpClient.ts
    # Should return nothing
  </verify>
  <done>
    - mcpClient.ts uses HTTP fetch to /mcp endpoint
    - Session ID tracked across requests
    - MCPToolCallResult interface preserved for backwards compatibility
    - Environment variable MCP_SERVER_URL supported
    - No direct imports of validation or database modules
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests</name>
  <files>
    backend/src/__tests__/mcp/mcpIntegration.test.ts
  </files>
  <action>
Create integration tests that verify the full HTTP MCP flow.

1. Create `backend/src/__tests__/mcp/mcpIntegration.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';
import express from 'express';
import { Server } from 'http';
import { mcpTransportRouter } from '../../mcp/mcpRoutes';
import { MCPHttpClient } from '../../mcp/mcpClient';
import { getSessionManager } from '../../mcp/mcpSessionManager';

describe('MCP HTTP Transport Integration', () => {
  let app: express.Application;
  let server: Server;
  let baseUrl: string;
  let client: MCPHttpClient;

  beforeAll(async () => {
    // Create test server
    app = express();
    app.use(express.json());
    app.use('/mcp', mcpTransportRouter);

    // Start on random port
    server = app.listen(0);
    const address = server.address() as { port: number };
    baseUrl = `http://localhost:${address.port}`;

    client = new MCPHttpClient(baseUrl);
  });

  afterAll(async () => {
    await client.disconnect();
    server.close();
  });

  describe('Session Management', () => {
    it('creates session on initialize', async () => {
      await client.initialize();
      const status = client.getStatus();
      expect(status.isConnected).toBe(true);
      expect(status.sessionId).toBeTruthy();
    });

    it('tracks session across multiple tool calls', async () => {
      const client2 = new MCPHttpClient(baseUrl);
      await client2.initialize();

      const sessionId1 = client2.getStatus().sessionId;

      // Make tool call
      await client2.getInformationSchema();

      // Session should be same
      const sessionId2 = client2.getStatus().sessionId;
      expect(sessionId1).toBe(sessionId2);

      await client2.disconnect();
    });

    it('terminates session on disconnect', async () => {
      const client3 = new MCPHttpClient(baseUrl);
      await client3.initialize();
      const sessionId = client3.getStatus().sessionId;

      // Verify session exists
      expect(getSessionManager().getSession(sessionId!)).toBeTruthy();

      // Disconnect
      await client3.disconnect();

      // Session should be gone
      expect(getSessionManager().getSession(sessionId!)).toBeUndefined();
    });
  });

  describe('Tool Execution', () => {
    it('executes get_information_schema', async () => {
      const result = await client.getInformationSchema();
      expect(result.success).toBe(true);
      expect(result.result).toHaveProperty('schema');
    });

    it('validates SQL query', async () => {
      const result = await client.validateSQLQuery('SELECT * FROM county_data LIMIT 10');
      expect(result.success).toBe(true);
      expect(result.result).toHaveProperty('valid', true);
    });

    it('rejects invalid SQL', async () => {
      const result = await client.validateSQLQuery('DROP TABLE county_data');
      expect(result.success).toBe(false);
    });

    it('executes valid query', async () => {
      const result = await client.executeQuery('SELECT COUNT(*) as cnt FROM county_data');
      expect(result.success).toBe(true);
      expect(result.result).toHaveProperty('data');
    });
  });

  describe('Error Handling', () => {
    it('returns error for invalid session ID', async () => {
      const response = await fetch(`${baseUrl}/mcp`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Mcp-Session-Id': 'invalid-session-id',
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: 1,
          method: 'tools/call',
          params: { name: 'get_information_schema' },
        }),
      });

      expect(response.status).toBe(400);
    });

    it('returns 404 for DELETE with unknown session', async () => {
      const response = await fetch(`${baseUrl}/mcp`, {
        method: 'DELETE',
        headers: { 'Mcp-Session-Id': 'unknown-session' },
      });

      expect(response.status).toBe(404);
    });
  });
});
```

2. Update Jest config if needed to handle the new test file location.

3. Run tests:
   ```bash
   cd backend && npm test -- --testPathPattern="mcpIntegration"
   ```
  </action>
  <verify>
    cd backend && npm test -- --testPathPattern="mcpIntegration" --verbose
  </verify>
  <done>
    - Integration test file exists at backend/src/__tests__/mcp/mcpIntegration.test.ts
    - Tests cover session lifecycle (create, persist, terminate)
    - Tests cover tool execution (schema, validate, execute)
    - Tests cover error cases (invalid session, unknown session)
    - All tests pass
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete MCP HTTP transport migration:
    - SDK upgraded to 1.25.3
    - Server uses StreamableHTTPServerTransport with session management
    - Client uses HTTP fetch instead of in-process calls
    - /mcp endpoints: POST (requests), GET (SSE), DELETE (terminate)
  </what-built>
  <how-to-verify>
    1. Start the backend server:
       ```bash
       cd backend && npm run dev
       ```

    2. Test with curl - Initialize session:
       ```bash
       curl -i -X POST http://localhost:3001/mcp \
         -H "Content-Type: application/json" \
         -H "Accept: application/json, text/event-stream" \
         -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","clientInfo":{"name":"test","version":"1.0.0"},"capabilities":{}}}'
       ```
       Expected: 200 response with `Mcp-Session-Id` header

    3. Copy the session ID and call a tool:
       ```bash
       curl -X POST http://localhost:3001/mcp \
         -H "Content-Type: application/json" \
         -H "Accept: application/json, text/event-stream" \
         -H "Mcp-Session-Id: YOUR_SESSION_ID" \
         -d '{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{"name":"execute_query","arguments":{"query":"SELECT COUNT(*) as county_count FROM county_data"}}}'
       ```
       Expected: JSON-RPC response with query results

    4. (Optional) Test with Claude Desktop:
       - Add server config to claude_desktop_config.json:
         ```json
         {
           "mcpServers": {
             "censuschat": {
               "url": "http://localhost:3001/mcp"
             }
           }
         }
         ```
       - Restart Claude Desktop
       - Use tool: "Query county count" should trigger execute_query

    5. Terminate session:
       ```bash
       curl -X DELETE http://localhost:3001/mcp \
         -H "Mcp-Session-Id: YOUR_SESSION_ID"
       ```
       Expected: 204 No Content
  </how-to-verify>
  <resume-signal>Type "approved" if MCP endpoints work correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Build passes:
   ```bash
   cd backend && npm run build
   ```

2. All tests pass:
   ```bash
   cd backend && npm test
   ```

3. Manual verification with curl (see checkpoint task)

4. Session count stays bounded:
   ```bash
   # After multiple connects/disconnects, session manager should clean up
   ```
</verification>

<success_criteria>
- mcpClient.ts uses HTTP fetch (no direct imports of validator/duckdb)
- Client tracks session ID from initialize response
- Integration tests pass (session lifecycle + tool execution)
- External curl commands successfully:
  - Initialize session and get session ID
  - Call tools with session ID
  - Terminate session
- Human verification confirms Claude Desktop connectivity (optional but recommended)
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-transport-migration/02-02-SUMMARY.md`
</output>
