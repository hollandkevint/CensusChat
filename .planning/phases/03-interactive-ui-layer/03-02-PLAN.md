---
phase: 03-interactive-ui-layer
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - mcp-apps/src/data-table/index.html
  - mcp-apps/src/data-table/main.tsx
  - mcp-apps/src/data-table/DataTable.tsx
  - mcp-apps/src/data-table/columns.tsx
  - backend/src/mcp/mcpServer.ts
  - backend/src/routes/mcp.routes.ts
  - frontend/src/components/ChatInterface.tsx
autonomous: true

must_haves:
  truths:
    - "Data tables sort by any column when user clicks column header"
    - "User can filter table rows without re-running the query"
    - "Clicking a county in results shows block groups within that county"
  artifacts:
    - path: "mcp-apps/src/data-table/main.tsx"
      provides: "MCP App entry point with App class connection"
      contains: "App"
    - path: "mcp-apps/src/data-table/DataTable.tsx"
      provides: "TanStack Table with sorting and filtering"
      exports: ["DataTable"]
    - path: "backend/src/mcp/mcpApps/data-table.html"
      provides: "Built single-file HTML bundle"
      min_lines: 100
    - path: "frontend/src/components/ChatInterface.tsx"
      provides: "App Bridge integration for UI resources"
      contains: "AppBridge"
    - path: "backend/src/routes/mcp.routes.ts"
      provides: "API endpoint for UI resources"
      contains: "mcp/resources"
  key_links:
    - from: "mcp-apps/src/data-table/main.tsx"
      to: "MCP host"
      via: "App.connect()"
      pattern: "app\\.connect\\(\\)"
    - from: "mcp-apps/src/data-table/DataTable.tsx"
      to: "TanStack Table"
      via: "useReactTable hook"
      pattern: "useReactTable"
    - from: "frontend/src/components/ChatInterface.tsx"
      to: "AppBridge"
      via: "conditional render for UI resources"
      pattern: "AppBridge.*resourceHtml"
    - from: "frontend/src/components/ChatInterface.tsx"
      to: "/api/v1/mcp/resources"
      via: "fetch call on mount"
      pattern: "fetch.*mcp/resources"
---

<objective>
Create interactive data table MCP App with TanStack Table for sorting and filtering, plus drill-down navigation from county to block groups.

Purpose: Replace static table rendering with interactive, sortable, filterable data grid that supports drill-down exploration.
Output: Built data-table.html MCP App, integrated into ChatInterface via App Bridge
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-interactive-ui-layer/03-RESEARCH.md
@.planning/phases/03-interactive-ui-layer/03-01-SUMMARY.md

# Files from Plan 01
@mcp-apps/vite.config.ts
@mcp-apps/src/shared/app-bridge.ts
@frontend/src/components/AppBridge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Data Table MCP App source</name>
  <files>
    mcp-apps/src/data-table/index.html
    mcp-apps/src/data-table/main.tsx
    mcp-apps/src/data-table/DataTable.tsx
    mcp-apps/src/data-table/columns.tsx
    mcp-apps/src/data-table/styles.css
  </files>
  <action>
**index.html:**
Basic HTML shell with React root div, Tailwind CDN (play.tailwindcss.com CDN for simplicity), and main.tsx script.

**main.tsx:**
Entry point that:
1. Imports App from @modelcontextprotocol/ext-apps
2. Creates App instance with name 'CensusChat Data Table'
3. Sets app.ontoolresult handler to receive query data
4. Renders DataTable component to #root
5. Calls app.connect()

State management:
- data: any[] (from tool result)
- breadcrumbs: Array<{fips: string, name: string}> (navigation trail)
- loading: boolean

**DataTable.tsx:**
TanStack Table implementation with:

1. useReactTable hook with:
   - getCoreRowModel()
   - getSortedRowModel()
   - getFilteredRowModel()
   - getPaginationRowModel()

2. Column sorting:
   - Click header to sort asc/desc
   - Show sort direction indicator (arrow up/down)
   - Enable multi-column sort with shift+click

3. Column filtering:
   - Text input above each column (collapsible)
   - String columns: contains filter
   - Number columns: min/max range filter
   - Toggle filter visibility button

4. Pagination:
   - Page size selector (10, 25, 50, 100)
   - Page navigation buttons
   - "Showing X-Y of Z records" display

5. Drill-down:
   - If row has county_fips column, make county name clickable
   - onClick calls app.callServerTool() with block group query
   - Update breadcrumbs for back navigation
   - Breadcrumb click navigates back up hierarchy

6. Styling with Tailwind:
   - Responsive table container
   - Sticky header row
   - Alternating row colors
   - Hover highlight on rows
   - Clear focus states for accessibility

**columns.tsx:**
Dynamic column definition generator:
- Takes data[0] keys to create columns
- Formats numbers with toLocaleString()
- Formats column headers (replace _ with space, capitalize)
- Marks county_name/county_fips as drillable

**styles.css:**
Minimal custom styles for table (most styling via Tailwind classes)
  </action>
  <verify>
```bash
ls mcp-apps/src/data-table/
grep -l "useReactTable" mcp-apps/src/data-table/DataTable.tsx
grep -l "getSortedRowModel" mcp-apps/src/data-table/DataTable.tsx
grep -l "getFilteredRowModel" mcp-apps/src/data-table/DataTable.tsx
grep -l "callServerTool" mcp-apps/src/data-table/main.tsx || grep -l "callServerTool" mcp-apps/src/data-table/DataTable.tsx
```
  </verify>
  <done>
Data table MCP App source files exist with TanStack Table sorting, filtering, pagination, and drill-down
  </done>
</task>

<task type="auto">
  <name>Task 2: Build data-table.html and update MCP server</name>
  <files>
    backend/src/mcp/mcpApps/data-table.html
    backend/src/mcp/mcpServer.ts
  </files>
  <action>
**Build the MCP App:**
```bash
cd mcp-apps && npm run build
```

This should output data-table.html to backend/src/mcp/mcpApps/

**Verify build output:**
- Single HTML file with inlined JS/CSS
- File size should be under 500KB (reasonable bundle)
- Contains all React components and TanStack Table

**Update mcpServer.ts pagination support:**

Add pagination metadata to execute_query response:
```typescript
interface PaginatedResponse {
  success: true;
  data: any[];
  metadata: {
    rowCount: number;
    hasMore: boolean;
    nextCursor?: string;
    tables: string[];
    columns: string[];
  };
}
```

Modify handleExecuteQuery:
- If query has LIMIT, track if there might be more rows
- Include cursor (last geoid) for next page if applicable
- Add hasMore: boolean to metadata

**Add drill-down query support:**
Add new tool execute_drill_down_query:
```typescript
server.tool(
  'execute_drill_down_query',
  'Execute a drill-down query for block groups within a county',
  {
    countyFips: z.string().describe('County FIPS code to drill into'),
    cursor: z.string().optional().describe('Cursor for pagination')
  },
  async (args) => {
    const query = `
      SELECT geoid, name, total_population, median_household_income,
             pct_65_and_over, pct_with_health_insurance
      FROM block_group_data_expanded
      WHERE LEFT(geoid, 5) = '${args.countyFips}'
      ${args.cursor ? `AND geoid > '${args.cursor}'` : ''}
      ORDER BY geoid
      LIMIT 101
    `;
    // Execute via existing validator and pool
    // Return 100 rows, hasMore if 101st exists
  }
);
```

Use cursor-based pagination (geoid column) not OFFSET.
  </action>
  <verify>
```bash
ls -la backend/src/mcp/mcpApps/data-table.html
wc -c backend/src/mcp/mcpApps/data-table.html  # Should be < 500KB
grep -n "execute_drill_down_query" backend/src/mcp/mcpServer.ts
grep -n "hasMore" backend/src/mcp/mcpServer.ts
```
  </verify>
  <done>
data-table.html exists in mcpApps directory, MCP server has drill-down tool and pagination metadata
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate App Bridge into ChatInterface and create UI resources endpoint</name>
  <files>
    frontend/src/components/ChatInterface.tsx
    frontend/src/lib/api/queryApi.ts
    backend/src/routes/mcp.routes.ts
  </files>
  <action>
**Create backend route for UI resources (mcp.routes.ts):**

Create or modify `backend/src/routes/mcp.routes.ts` to add GET /api/v1/mcp/resources endpoint:

```typescript
import { Router } from 'express';
import { readFileSync, existsSync, readdirSync } from 'fs';
import { join } from 'path';

const router = Router();

// GET /api/v1/mcp/resources - Return available UI resources
router.get('/resources', (req, res) => {
  const mcpAppsDir = join(__dirname, '../mcp/mcpApps');
  const resources: Array<{ uri: string; html: string }> = [];

  if (existsSync(mcpAppsDir)) {
    const files = readdirSync(mcpAppsDir).filter(f => f.endsWith('.html'));
    for (const file of files) {
      const html = readFileSync(join(mcpAppsDir, file), 'utf-8');
      resources.push({
        uri: `ui://censuschat/${file}`,
        html
      });
    }
  }

  res.json(resources);
});

export default router;
```

**Register the route in routes/index.ts:**
Ensure the MCP routes are mounted at `/mcp`:
```typescript
import mcpRoutes from './mcp.routes';
// ...
router.use('/mcp', mcpRoutes);
```

**Modify ChatInterface.tsx:**

Add imports:
```typescript
import { AppBridge } from './AppBridge';
```

Add state for UI resources:
```typescript
const [uiResources, setUIResources] = useState<Map<string, string>>(new Map());
```

**Fetch UI resources on mount:**
Add useEffect to fetch available UI resources from MCP server:
```typescript
useEffect(() => {
  // Fetch UI resource HTML from backend
  async function loadUIResources() {
    try {
      const response = await fetch('/api/v1/mcp/resources');
      const resources = await response.json();
      const resourceMap = new Map();
      for (const r of resources) {
        resourceMap.set(r.uri, r.html);
      }
      setUIResources(resourceMap);
    } catch (error) {
      console.warn('UI resources not available, falling back to static tables');
    }
  }
  loadUIResources();
}, []);
```

**Modify message rendering:**
In the message rendering section, check if UI resource available:
```typescript
{message.data && !message.isLoading && (
  uiResources.has('ui://censuschat/data-table.html') ? (
    <AppBridge
      resourceUri="ui://censuschat/data-table.html"
      resourceHtml={uiResources.get('ui://censuschat/data-table.html')!}
      toolResult={{ success: true, data: message.data, metadata: message.metadata }}
      onDrillDown={handleDrillDown}
      className="mt-4 h-96"
    />
  ) : (
    renderDataTable(message.data)
  )
)}
```

**Add drill-down handler:**
```typescript
const handleDrillDown = async (params: { countyFips: string, countyName: string }) => {
  // Add loading message
  // Call drill-down API
  // Update messages with block group results
};
```

**Keep renderDataTable as fallback:**
Don't remove existing renderDataTable - use it when UI resources unavailable.

**Update queryApi.ts:**
Add endpoint for fetching UI resources:
```typescript
async getUIResources(): Promise<Array<{uri: string, html: string}>> {
  const response = await this.client.get('/mcp/resources');
  return response.data;
}
```
  </action>
  <verify>
```bash
grep -n "AppBridge" frontend/src/components/ChatInterface.tsx
grep -n "uiResources" frontend/src/components/ChatInterface.tsx
grep -n "handleDrillDown" frontend/src/components/ChatInterface.tsx
grep -n "/resources" backend/src/routes/mcp.routes.ts
grep -n "ui://censuschat" backend/src/routes/mcp.routes.ts
cd frontend && npm run typecheck
cd backend && npm run typecheck
```
  </verify>
  <done>
ChatInterface renders AppBridge for data tables when UI resources available, falls back to static table otherwise. GET /api/v1/mcp/resources endpoint returns available UI resources with HTML content.
  </done>
</task>

</tasks>

<verification>
1. MCP App source exists: `ls mcp-apps/src/data-table/`
2. Built HTML exists: `ls backend/src/mcp/mcpApps/data-table.html`
3. TanStack Table used: `grep "useReactTable" mcp-apps/src/data-table/DataTable.tsx`
4. Sorting works: `grep "getSortedRowModel" mcp-apps/src/data-table/DataTable.tsx`
5. Filtering works: `grep "getFilteredRowModel" mcp-apps/src/data-table/DataTable.tsx`
6. Drill-down tool: `grep "execute_drill_down_query" backend/src/mcp/mcpServer.ts`
7. AppBridge integrated: `grep "AppBridge" frontend/src/components/ChatInterface.tsx`
8. UI resources endpoint: `grep "/resources" backend/src/routes/mcp.routes.ts`
9. TypeScript compiles: `cd frontend && npm run typecheck && cd ../backend && npm run typecheck`
</verification>

<success_criteria>
- Data table MCP App source files in mcp-apps/src/data-table/
- Built data-table.html in backend/src/mcp/mcpApps/
- TanStack Table with sorting (click header toggles asc/desc)
- TanStack Table with column filtering (text/number filters)
- Drill-down navigation (county -> block groups)
- Breadcrumb trail for drill-down navigation
- ChatInterface uses AppBridge when UI resources available
- Graceful fallback to static renderDataTable when not available
- Cursor-based pagination for large result sets
- GET /api/v1/mcp/resources endpoint returns UI resources with HTML
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-interactive-ui-layer/03-02-SUMMARY.md`
</output>
