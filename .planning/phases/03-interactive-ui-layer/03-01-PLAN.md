---
phase: 03-interactive-ui-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/package.json
  - frontend/package.json
  - mcp-apps/package.json
  - mcp-apps/vite.config.ts
  - mcp-apps/tsconfig.json
  - backend/src/mcp/mcpServer.ts
  - frontend/src/components/AppBridge.tsx
autonomous: true

must_haves:
  truths:
    - "MCP Apps build pipeline produces single-file HTML bundles"
    - "App Bridge renders iframe with sandbox='allow-scripts'"
    - "MCP server registers UI resources at ui:// URIs"
  artifacts:
    - path: "mcp-apps/package.json"
      provides: "Build tooling dependencies"
      contains: "vite-plugin-singlefile"
    - path: "mcp-apps/vite.config.ts"
      provides: "Single-file bundle configuration"
      contains: "viteSingleFile"
    - path: "frontend/src/components/AppBridge.tsx"
      provides: "Iframe host for MCP Apps"
      exports: ["AppBridge"]
    - path: "backend/src/mcp/mcpServer.ts"
      provides: "UI resource registration"
      contains: "registerAppResource"
  key_links:
    - from: "mcp-apps/vite.config.ts"
      to: "backend/src/mcp/mcpApps/*.html"
      via: "build output"
      pattern: "outDir.*mcpApps"
    - from: "frontend/src/components/AppBridge.tsx"
      to: "MCP App iframe"
      via: "srcDoc prop"
      pattern: "srcDoc=\\{resourceHtml\\}"
---

<objective>
Set up MCP Apps infrastructure: build pipeline for single-file HTML apps, App Bridge component for iframe rendering, and UI resource registration on MCP server.

Purpose: Foundation for interactive query results. MCP Apps enable tools to return UI components rendered in sandboxed iframes.
Output: Working build pipeline, App Bridge component, MCP server with UI resource support
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-interactive-ui-layer/03-RESEARCH.md

# Existing files to modify
@backend/src/mcp/mcpServer.ts
@backend/package.json
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP Apps build pipeline</name>
  <files>
    mcp-apps/package.json
    mcp-apps/vite.config.ts
    mcp-apps/tsconfig.json
    mcp-apps/src/shared/app-bridge.ts
  </files>
  <action>
Create a new `mcp-apps/` directory at project root with Vite build configuration for single-file HTML output.

**package.json:**
- Name: "censuschat-mcp-apps"
- Dependencies: react, react-dom, @modelcontextprotocol/ext-apps@1.0.1
- DevDependencies: vite@6.x, vite-plugin-singlefile@2.x, @vitejs/plugin-react, typescript
- Scripts: "build" compiles all apps to single-file HTML, "dev" for development

**vite.config.ts:**
- Use @vitejs/plugin-react and viteSingleFile plugins
- Set build.target to 'esnext'
- Set build.assetsInlineLimit to 100000000 (inline everything)
- Set build.cssCodeSplit to false
- Output to ../backend/src/mcp/mcpApps/

**tsconfig.json:**
- Target ES2022, module ESNext
- JSX: react-jsx
- Include src/**/*

**src/shared/app-bridge.ts:**
- Create wrapper around @modelcontextprotocol/ext-apps App class
- Export createApp() function that returns connected App instance
- Include TypeScript types for tool results and messages

Do NOT install dependencies yet - that happens in Task 2 verification.
  </action>
  <verify>
Files exist:
- `ls mcp-apps/package.json mcp-apps/vite.config.ts mcp-apps/tsconfig.json`
- `cat mcp-apps/vite.config.ts | grep viteSingleFile`
  </verify>
  <done>
Build pipeline configuration files exist with single-file output configured to backend/src/mcp/mcpApps/
  </done>
</task>

<task type="auto">
  <name>Task 2: Install dependencies and create App Bridge component</name>
  <files>
    backend/package.json
    frontend/package.json
    frontend/src/components/AppBridge.tsx
  </files>
  <action>
**Install dependencies:**

Backend:
```bash
cd backend && npm install @modelcontextprotocol/ext-apps@1.0.1
```

Frontend:
```bash
cd frontend && npm install @tanstack/react-table@8.21.3 @modelcontextprotocol/ext-apps@1.0.1
```

MCP Apps:
```bash
cd mcp-apps && npm install
```

**Create AppBridge.tsx:**
React component that renders MCP Apps in sandboxed iframes.

Props interface:
- resourceUri: string (ui:// URI)
- resourceHtml: string (HTML content)
- toolResult: any (data to pass to app)
- onMessage?: (message: any) => void (messages from app)
- onDrillDown?: (params: DrillDownParams) => void (drill-down requests)
- className?: string

Implementation:
1. Use useRef for iframe reference
2. Use useState for ready state
3. useEffect to handle postMessage communication:
   - Listen for 'ui/ready' from iframe, then send tool result
   - Listen for 'ui/message' and forward to onMessage
   - Listen for 'ui/drill-down' and forward to onDrillDown
4. Compare event.source to iframe.contentWindow for security
5. Render iframe with sandbox="allow-scripts" (NOT allow-same-origin)
6. Set srcDoc to resourceHtml
7. Style: w-full, h-96, border rounded-lg, responsive

Export both AppBridge and DrillDownParams type.
  </action>
  <verify>
```bash
cd backend && npm ls @modelcontextprotocol/ext-apps
cd frontend && npm ls @tanstack/react-table @modelcontextprotocol/ext-apps
cd mcp-apps && npm ls vite vite-plugin-singlefile
grep -l "AppBridge" frontend/src/components/AppBridge.tsx
```
  </verify>
  <done>
Dependencies installed in all three packages, AppBridge component exports AppBridge function
  </done>
</task>

<task type="auto">
  <name>Task 3: Add UI resource registration to MCP server</name>
  <files>
    backend/src/mcp/mcpServer.ts
    backend/src/mcp/mcpApps/.gitkeep
  </files>
  <action>
**Create mcpApps directory placeholder:**
```bash
mkdir -p backend/src/mcp/mcpApps
touch backend/src/mcp/mcpApps/.gitkeep
```

**Modify mcpServer.ts:**

Add imports:
```typescript
import { registerAppTool, registerAppResource, RESOURCE_MIME_TYPE } from '@modelcontextprotocol/ext-apps';
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
```

Add helper function to load UI resources:
```typescript
function loadUIResource(filename: string): string | null {
  const path = join(__dirname, 'mcpApps', filename);
  if (existsSync(path)) {
    return readFileSync(path, 'utf-8');
  }
  console.warn(`[MCP] UI resource not found: ${filename}`);
  return null;
}
```

**Modify execute_query tool registration:**
Use registerAppTool instead of server.tool() for execute_query:
- Add _meta.ui with resourceUri: 'ui://censuschat/data-table.html'
- Add visibility: ['model', 'app']

**Add UI resource registration function:**
```typescript
function registerUIResources(server: McpServer): void {
  const resources = [
    { name: 'data-table.html', uri: 'ui://censuschat/data-table.html' },
    { name: 'bar-chart.html', uri: 'ui://censuschat/bar-chart.html' },
    { name: 'line-chart.html', uri: 'ui://censuschat/line-chart.html' }
  ];

  for (const resource of resources) {
    const html = loadUIResource(resource.name);
    if (html) {
      registerAppResource(
        server,
        resource.uri,
        resource.uri,
        { mimeType: RESOURCE_MIME_TYPE },
        async () => ({ text: html })
      );
      console.log(`[MCP] Registered UI resource: ${resource.uri}`);
    }
  }
}
```

Call registerUIResources(server) at end of createMcpServer() before return.

**Important:** Keep existing tools (get_information_schema, validate_sql_query) unchanged. Only modify execute_query to use registerAppTool.

**Fallback behavior:** If UI resources not found, tools still work but return JSON only (graceful degradation).
  </action>
  <verify>
```bash
grep -n "registerAppResource\|registerAppTool" backend/src/mcp/mcpServer.ts
grep -n "ui://censuschat" backend/src/mcp/mcpServer.ts
ls backend/src/mcp/mcpApps/
```
  </verify>
  <done>
MCP server imports ext-apps, registers UI resources, and execute_query tool has _meta.ui.resourceUri
  </done>
</task>

</tasks>

<verification>
1. Build pipeline ready: `ls mcp-apps/package.json mcp-apps/vite.config.ts`
2. Dependencies installed: `cd backend && npm ls @modelcontextprotocol/ext-apps`
3. App Bridge exists: `grep "export.*AppBridge" frontend/src/components/AppBridge.tsx`
4. MCP server updated: `grep "registerAppResource" backend/src/mcp/mcpServer.ts`
5. Backend compiles: `cd backend && npm run typecheck`
6. Frontend compiles: `cd frontend && npm run typecheck`
</verification>

<success_criteria>
- mcp-apps/ directory exists with Vite config for single-file output
- @modelcontextprotocol/ext-apps installed in backend and frontend
- @tanstack/react-table installed in frontend
- AppBridge.tsx exports AppBridge component with iframe rendering
- mcpServer.ts uses registerAppTool for execute_query with UI resource
- mcpServer.ts registers UI resources at ui:// URIs
- TypeScript compiles without errors in both backend and frontend
</success_criteria>

<output>
After completion, create `.planning/phases/03-interactive-ui-layer/03-01-SUMMARY.md`
</output>
